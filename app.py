from flask import Flask, render_template, request
from flask_socketio import SocketIO, join_room, leave_room, emit
from flask_cors import CORS
import random
from threading import Thread, Lock
import time
import logging
import requests
import asyncio

# Basic logging setup
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

pregenerated_locations = {}

app = Flask(__name__)
CORS(app, resources={r"/socket.io/*": {"origins": ["https://otterguessr.ermine.at", "http://localhost:5000"]}})
app.config['SECRET_KEY'] = 'multiplayerisreal'
socketio = SocketIO(app, logger=True, engineio_logger=True, cors_allowed_origins="*")


rooms = {}  # Stores room details
user_rooms = {}  # Maps users to their rooms
user_nicknames = {}  # Maps users to their nicknames
rooms_lock = Lock()  # Lock for thread-safe operations on rooms
user_scores = {}  # Dictionary to store user scores
user_nicknames = {}  # Dictionary to store user nicknames

def generate_random_nickname():
    animals = [
    "Molen", "Weasel", "Fennec", "Fox", "Skunk", "Sergal", "Ferret", "BlueJay", "Wushul"]
    adjectives = [
    "Fluffy", "Giant", "River", "Cute", "Playful", "Agile", "Swift", "Majestic",
    "Clever", "Lively", "Elegant", "Graceful", "Joyful", "Friendly", "Gentle",
    "Happy", "Jolly", "Kind", "Lovely", "Nice", "Pleasant", "Proud", "Silly",
    "Witty", "Brave", "Calm", "Cozy", "Daring", "Dazzling", "Dreamy", "Dynamic",
    "Fancy", "Fierce", "Gleaming", "Glorious", "Golden", "Graceful", "Grateful",
    "Handsome", "Loyal", "Lucky", "Merry", "Mighty", "Peaceful", "Perfect", "Plucky",
    "Radiant", "Rapid", "Royal", "Shiny", "Sleek", "Smart", "Sparkling", "Speedy",
    "Spunky", "Starry", "Strong", "Stunning", "Super", "Talented", "Tender",
    "Terrific", "Valiant", "Vibrant", "Vigorous", "Wise", "Wonderful", "Youthful",
    "Zany", "Zealous", "Zippy", "Bouncy", "Bright", "Bubbly", "Bursting", "Busy",
    "Charming", "Cheerful", "Cherished", "Chic", "Classic", "Comical", "Curious",
    "Dainty", "Delightful", "Elated", "Energetic", "Enthusiastic", "Exquisite",
    "Fantastic", "Fiery", "Frolicsome", "Giggly", "Gleeful", "Glowing", "Goodly",
    "Gracious", "Hilarious", "Honest", "Inventive", "Jazzy", "Jovial", "Joyous"]

    adjective = random.choice(adjectives)
    animal = random.choice(animals)
    return adjective + animal + str(random.randint(1000, 9999))

@app.route('/')
def index():
    app.logger.info('Processing default route')
    return render_template('index.html')
    pass

async def check_land_or_water(lat, lng):
    nominatim_url = f"https://nominatim.openstreetmap.org/reverse?format=json&lat={lat}&lon={lng}"
    response = requests.get(nominatim_url, headers={'User-Agent': 'YourAppName/YourEmail'})
    data = response.json()
    if not data or not data.get('address') or 'ocean' in data.get('display_name', ''):
        return False
    return True
    
async def pregenerate_locations(num_rounds, selected_country):
    locations = []
    logger.debug("SYNDICATION: Locations are being pregenerated.")
    while len(locations) < num_rounds:
        lat, lng = generate_random_coordinates(selected_country)
        if await check_land_or_water(lat, lng):
            locations.append({'lat': lat, 'lng': lng})
            logger.debug(f"SYNDICATION: Generated location {len(locations)}: {lat}, {lng}")
    logger.debug("SYNDICATION COMPLETE: Locations have been pregenerated.")
    return locations


@socketio.on('pregenerate_locations')
async def handle_pregenerate_locations(data):
    room_id = data.get('room_id')
    num_rounds = data.get('num_rounds', 5)
    selected_country = data.get('selected_country', 'all')

    # Inform all players in the room that pregeneration is starting
    emit('pregenerating_locations', {'message': 'SYNDICATION: Locations are starting to be generated by the admin.'}, room=room_id, include_self=False)
    emit('pregenerating_locations_admin', {'message': 'SYNDICATION: Locations are being pregenerated.'}, room=request.sid)

    # Generating locations for the room
    locations = await pregenerate_locations(num_rounds, selected_country)
    pregenerated_locations[room_id] = locations

    # Broadcasting pregenerated locations to all users in the room and a special message to the admin
    emit('locations_pregenerated', {'num_rounds': len(locations), 'locations': locations}, room=room_id)
    emit('pregenerated_admin_notification', {'num_rounds': len(locations)}, room=request.sid)
    print(f"Debug: Pregenerated {len(locations)} locations for room {room_id}")


    
    
@socketio.on('connect')
def on_connect():
    user_id = request.sid
    nickname = generate_random_nickname()
    user_nicknames[user_id] = nickname
    user_scores[user_id] = 0  # Initialize user score
    print(f"Debug: User {user_id} connected with nickname {nickname}")
    emit('assigned_nickname', {'nickname': nickname})


@socketio.on('update_score')
def handle_score_update(data):
    user_id = request.sid
    score = data['score']
    user_scores[user_id] = score
    update_scoreboard()
    
def update_scoreboard():
    sorted_scores = sorted(user_scores.items(), key=lambda x: x[1], reverse=True)
    scoreboard = [{"nickname": user_nicknames[user_id], "score": score} for user_id, score in sorted_scores[:10]]
    socketio.emit('scoreboard_update', {'scoreboard': scoreboard})
    print("Scoreboard updated")

@socketio.on('update_scoreboard')
def handle_update_scoreboard(data):
    user_id = request.sid
    score = data['score']
    user_scores[user_id] = score  # Update the user's score

    room_id = user_rooms.get(user_id)
    if room_id:
        # Sort and send updated scoreboard only to players in the same room
        sorted_scores = sorted([(uid, score) for uid, score in user_scores.items() if user_rooms.get(uid) == room_id], key=lambda x: x[1], reverse=True)
        scoreboard = [{"nickname": user_nicknames[user_id], "score": score} for user_id, score in sorted_scores[:10]]
        emit('scoreboard_updated', {'scoreboard': scoreboard}, room=room_id)


    
@socketio.on('create')
def on_create(data):
    with rooms_lock:
        user_id = request.sid
        nickname = user_nicknames.get(user_id, "Unknown")
        room_id = data['room']
        print(f"Debug: {nickname} attempting to create server {room_id}")

        if room_id in rooms:
            emit('room_creation_failed', {'message': f'Room {room_id} already exists.'})
            return

        rooms[room_id] = {
            'users': {user_id: {'nickname': nickname, 'admin': True}},
            'created_at': time.time(),
            'game_settings': data.get('game_settings', {}),
            'game_started': False
        }
        user_rooms[user_id] = room_id
        join_room(room_id)

        # Updated message to include the username of the creator
        success_message = f"Room {room_id} created successfully. Your username is {nickname}. Share the name of the room with others to let them join!"
        emit('room_created', {'message': success_message, 'room': room_id}, room=room_id)

        print(f"Debug: {nickname} has successfully created server {room_id}")


game_round_data = {}  # Add this global variable to track round data

def getPlayersInRoom(room_id):
    players_in_room = []
    for user_id, user_room in user_rooms.items():
        if user_room == room_id:
            player_info = {
                'user_id': user_id,
                'nickname': user_nicknames.get(user_id, "Unknown")
            }
            players_in_room.append(player_info)
    return players_in_room

@socketio.on('reset_scoreboard')
def handle_reset_scoreboard(data):
    room_id = data['room']
    with rooms_lock:
        if room_id in rooms:
            # Reset scores for all users in the room
            for user_id in rooms[room_id]['users']:
                user_scores[user_id] = 0
            print(f"Scoreboard reset for room {room_id}")

            # Optionally, emit an event to update the scoreboard for clients
            update_scoreboard(room_id)


@socketio.on('create_multiplayer_game')
def on_create_multiplayer_game(data):
    user_id = request.sid
    if user_id not in user_rooms:
        print(f"Debug: User {user_id} not in any room")
        return

    room_id = user_rooms[user_id]
    print(f"Debug: User {user_id} creating multiplayer game in room {room_id}")

    if room_id in rooms:
        rooms[room_id]['game_settings'] = data
        game_round_data[room_id] = {'current_round': 0, 'round_details': []}
        emit('multiplayer_game_created', data, room=room_id)
        print(f"Debug: Multiplayer game created in room {room_id}")

@socketio.on('start_round')
def on_start_round(data):
    print(f"Debug: start_round event data: {data}")  # This will help you understand what data is being passed
    user_id = request.sid
    room_id = user_rooms.get(user_id)

    if not room_id:
        print(f"Debug: User {user_id} not in any room, can't start round")
        return

    print(f"Debug: Requesting coordinates for new round in room {room_id}")
    emit('request_coordinates', room=room_id)

    if room_id in game_round_data:
        current_round = game_round_data[room_id]['current_round']
        print(f"Debug: Starting round {current_round + 1} in room {room_id}")

        # Generate random coordinates for the StreetView location
        lat, lng = generate_random_coordinates()  # Ensure this function exists or implement it

        lat, lng = generate_random_coordinates()
        emit('new_round', {'round_number': current_round + 1, 'lat': lat, 'lng': lng}, room=room_id)

        # Increment the round number for the next call
        game_round_data[room_id]['current_round'] += 1



@socketio.on('provide_coordinates')
def on_provide_coordinates(data):
    print(f"Debug: Received provide_coordinates event with data: {data}")
    if not data or 'lat' not in data or 'lng' not in data:
        print(f"Debug: Invalid data received for coordinates: {data}")
        return  # Early return if data is invalid

    lat, lng = data['lat'], data['lng']
    user_id = request.sid
    room_id = user_rooms.get(user_id)

    if not room_id:
        print(f"Debug: User {user_id} not in any room, can't proceed with round")
        return

    # Emit the new round data to all clients in the room
    emit('new_round', {'round_number': current_round + 1, 'lat': lat, 'lng': lng}, room=room_id)
    print(f"Debug: Emitting new_round event to room {room_id} with lat: {lat}, lng: {lng}")

    # Increment the round number for the next call
    game_round_data[room_id]['current_round'] += 1

@socketio.on('sync_streetview_data')
def on_sync_streetview_data(data):
    # Emit StreetView data to all players in the same room
    print("Syncing StreetView data:", data)
    emit('streetview_data', data, room=data['room'])
    
    
@socketio.on('join')
def on_join(data):
    with rooms_lock:
        user_id = request.sid
        nickname = user_nicknames.get(user_id, "Unknown")
        room_id = data['room']
        print(f"{nickname} joining room {room_id}")

        if room_id not in rooms or len(rooms[room_id]['users']) >= 10:
            emit('join_error', {'message': f'Cannot join room {room_id}.'})
            return

        rooms[room_id]['users'][user_id] = {'nickname': nickname, 'admin': False}
        user_rooms[user_id] = room_id
        join_room(room_id)

        # Gather names of all players in the room
        player_names = [user['nickname'] for user in rooms[room_id]['users'].values()]
        player_names_str = ', '.join(player_names)

        # Identify the admin's nickname
        admin_id, admin_nickname = next(((uid, user['nickname']) for uid, user in rooms[room_id]['users'].items() if user['admin']), (None, "Unknown"))

        # Notify the user who just joined
        emit('join_room_announcement', {
            'message': f'You ({nickname}) joined room {room_id}. There are now {len(rooms[room_id]["users"])} players in the room. The admin is {admin_nickname}. Players: {player_names_str}',
            'user_id': user_id
        }, room=user_id)

        # Notify the admin of the room
        if admin_id:
            emit('admin_notification', {
                'message': f"User {nickname} joined your server {room_id}. There are now {len(rooms[room_id]['users'])} players in your server. Players: {player_names_str}"
            }, room=admin_id)


@socketio.on('admin_play_again')
def handle_admin_play_again(data):
    room_id = data['room']
    emit('play_again_triggered', room=room_id)
    print(f"Debug: Admin triggered 'Play Again' action in room {room_id}")

def generate_game_locations(num_rounds):
    locations = []
    for _ in range(num_rounds):
        lat, lng = generate_random_coordinates()  # Assuming this function exists
        locations.append({'lat': lat, 'lng': lng})
    return locations
    
    


@app.route('/pregenerate_locations', methods=['POST'])
def pregenerate_locations():
    data = request.get_json()
    room_id = data['room_id']
    num_rounds = data['num_rounds']

    if room_id not in pregenerated_locations:
        pregenerated_locations[room_id] = []

    for _ in range(num_rounds):
        lat, lng = generate_random_coordinates()
        pregenerated_locations[room_id].append({'lat': lat, 'lng': lng})

    return json.dumps({'message': f'{num_rounds} locations pregenerated for room {room_id}.'}), 200


@socketio.on('start_game')
def on_start_game(data):
    room_id = data['room']
    if room_id in rooms and rooms[room_id]['users'][request.sid]['admin']:
        rooms[room_id]['game_started'] = True
        if room_id in pregenerated_locations:
            game_locations[room_id] = pregenerated_locations.pop(room_id)
            print(f"Using pregenerated locations for room {room_id}")
        emit('game_started', rooms[room_id]['game_settings'], room=room_id)
        print(f"Debug: Game started in room {room_id} with settings {rooms[room_id]['game_settings']}")


@socketio.on('admin_pregenerated_locations')
def handle_admin_pregenerated_locations(data):
    room = data['room']
    locations = data['locations']
    # Broadcast to all clients in the room
    emit('locations_pregenerated', {'locations': locations, 'num_rounds': len(locations)}, room=room)




def get_available_rooms():
    with rooms_lock:  # Ensure thread-safe access to the rooms dictionary
        available_rooms = {}
        for room_id, room_info in rooms.items():
            available_rooms[room_id] = {
                'player_count': len(room_info['users']),
                'created_at': room_info['created_at']
            }
        return available_rooms

    
    

@socketio.on('list_rooms')
def handle_list_rooms():
    with rooms_lock:
        available_rooms = {}
        for room_id, room_info in rooms.items():
            player_list = [{"nickname": user_info['nickname'], "admin": user_info['admin']} for user_info in room_info['users'].values()]
            available_rooms[room_id] = {
                'player_count': len(room_info['users']),
                'players': player_list,
                'created_at': room_info['created_at']
            }
        emit('available_rooms', available_rooms)
        logger.debug(f"Available rooms: {available_rooms}")


@socketio.on('disconnect')
def on_disconnect():
    with rooms_lock:
        user_id = request.sid
        room_id = user_rooms.get(user_id)
        nickname = user_nicknames.get(user_id, "Unknown")

        if room_id and room_id in rooms:
            # Remove the user from the room
            del rooms[room_id]['users'][user_id]
            if not rooms[room_id]['users']:
                # Delete the room if it's empty
                del rooms[room_id]
                logger.debug(f"Deleted room {room_id} as it's empty.")
            else:
                # Notify other players in the room
                remaining_players = ', '.join([info['nickname'] for info in rooms[room_id]['users'].values()])
                player_count = len(rooms[room_id]['users'])
                admin = next((nick for uid, nick in user_nicknames.items() if uid in rooms[room_id]['users'] and rooms[room_id]['users'][uid]['admin']), "Unknown")
                emit('player_left_announcement', {'message': f"Player {nickname} left your current server {room_id}. There are {player_count} players left in the server - {remaining_players}.", 'admin': admin, 'player_count': player_count}, room=room_id)

            leave_room(room_id)
            logger.debug(f"{nickname} left room {room_id}")




def remove_expired_rooms():
    while True:
        with rooms_lock:
            current_time = time.time()
            expired_rooms = [room for room, data in rooms.items() if current_time - data['created_at'] > 3600]
            for room in expired_rooms:
                del rooms[room]
                print(f"Deleted expired room {room}")
        time.sleep(60)  # Check every minute

Thread(target=remove_expired_rooms, daemon=True).start()

if __name__ == '__main__':
    socketio.run(app, debug=True)
