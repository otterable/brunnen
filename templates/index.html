<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"> 
    <title>Otterguesser | Ermine.at </title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
		
        body, input, button {
           font-family: 'Roboto', sans-serif;
        }
		
		.guess-marker {
            background-color: blue;
            border: 1px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            height: 15px;
            width: 15px;
            position: absolute;
            user-select: none;
            transform: translate(-50%, -100%);
            z-index: 10;
        }

        .actual-marker {
            background-color: green;
            border: 1px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            height: 15px;
            width: 15px;
            position: absolute;
            user-select: none;
            transform: translate(-50%, -100%);
            z-index: 10;
        }
        

        #street-view {
            height: 100%;
        }
		
		#street-view .gm-style .gm-fullscreen-control {
        display: none !important;
		}

        #map {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 400px;
            height: 300px;
            border: 0px solid black;
			border-radius: 30px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 5;
        }


			 .gm-style-cc {
			display: none !important;
		}

		/* Hide the "Keyboard shortcuts" link */
		.gm-bundled-control-on-bottom {
			display: none !important;
		}

		/* Hide the "Report a problem" link specifically */
		.gm-legal {
			display: none !important;
		}
		
        #country-selector {
            position: absolute;
            bottom: 320px;
            right: 10px;
            z-index: 5;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
			color: black !important;
			border:none;
            background: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
			box-shadow: 0 0 10px rgba(0,0,0,0.5);
			border-radius: 30px;
            color: white;
            z-index: 10;
        }
		
		#reload-button {
            position: fixed;
			top: 60px; /* Adjust this if needed to clear the rounds window */
            left: 91.5%;
            transform: translateX(-50%);
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
			color: black !important;
			border:none;
            background: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
			box-shadow: 0 0 10px rgba(0,0,0,0.5);
			border-radius: 30px;
            color: white;
            z-index: 10;
			display:none;
        }
		

    #rounds-window {
            display: block; /* Changed from none to block */
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: white;
            padding: 10px;
            border-radius: 30px;
            background: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
			box-shadow: 0 0 10px rgba(0,0,0,0.5);

        }

    #score-display {
        position: absolute;
        top: 60px; /* Adjusted top position */
        right: 10px;
        z-index: 10;
        background: white;
        padding: 10px;
        border-radius: 30px;
		background: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
		box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }

    #game-over {
        display: none;
        position: absolute;
        top: 198px;
        right: 10px;
        z-index: 20;
        background: white;
        padding: 10px;
        border-radius: 30px;
				box-shadow: 0 0 10px rgba(0,0,0,0.5);

        background: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
        text-align: center;
    }
	
	#timer-display {
       position: absolute;
        top: 107px; /* Adjusted top position */
        right: 10px;
        z-index: 10;
        background: white;
        padding: 10px;
        border-radius: 30px;
				box-shadow: 0 0 10px rgba(0,0,0,0.5);

		background: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
    }

  #osm-id-input, #load-button {
    display: block;
    position: absolute;
    z-index: 10;
    background: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
    padding: 10px;
    border-radius: 30px;
    border: none; /* Optional: removes the default border */
    margin-bottom: 5px; /* To add some space between the input and the button */
			box-shadow: 0 0 10px rgba(0,0,0,0.5);

  }

  #osm-id-input {
    top: 154px; /* Adjusted top position */
    right: 125px;
  }

  #load-button {
    top: 154px; /* Adjusted top position to place it below the input */
    right: 10px;
  }
  
  
  #wiesel-image {
    position: absolute;
    bottom: 300px; /* Adjusted bottom position */
    right: 150px; /* Adjusted right position */
	max-width: 100px;
    z-index: 5; /* Adjust z-index as needed */
  }
  
   #description-text {
    position: absolute;
    bottom: 10px; /* Align with the bottom of the image */
    left: 10px; /* Adjusted right position to appear next to the image */
    z-index: 6; /* Ensures the text is above the image if they overlap */
    background: rgba(255, 255, 255, 0.9); /* Semi-transparent white background */
    padding: 10px;
    border-radius: 10px;
    width: 300px; /* Set a fixed width for the text box */
  }

    </style>
</head>
<body>
    <div id="street-view"></div>
    <div id="map"></div>
    <select id="country-selector" onchange="updateCountry()">
        <option value="all">All Countries</option>

    </select>
    <script>
        function initialize() {
            updateCountry();
            fetchStreetView();
			            showRoundsWindow(); // Manage rounds window display
        }

        var radii = [50, 100, 500];  // Search radii in km
        var radiusIndex = 0;
        var map;  // Declare map variable

        // Initial bounding boxes for all continents
        var allBoundingBoxes = [
            { minLat: 34, maxLat: 71, minLng: -24, maxLng: 40 },  // Europe
            { minLat: -35, maxLat: 35, minLng: -17, maxLng: 51 },  // Africa
            { minLat: 24, maxLat: 77, minLng: -169, maxLng: -50 },  // North America
            { minLat: -10, maxLat: 77, minLng: 29, maxLng: 169 },  // Asia + Australia
        ];

        var boundingBoxes = allBoundingBoxes;  // Default bounding boxes

        // Country-specific bounding boxes
        var countryBoundingBoxes = {
            us: { minLat: 24, maxLat: 49, minLng: -125, maxLng: -66 },
            fr: { minLat: 41, maxLat: 51, minLng: -5, maxLng: 8 },
            de: { minLat: 47, maxLat: 55, minLng: 5, maxLng: 15 },
            it: { minLat: 35, maxLat: 47, minLng: 6, maxLng: 19 },
            jp: { minLat: 30, maxLat: 45, minLng: 129, maxLng: 146 },
            ru: { minLat: 41, maxLat: 81, minLng: 19, maxLng: 169 },
			at: { minLat: 46.4, maxLat: 49, minLng: 9.5, maxLng: 17 },
            de: { minLat: 47, maxLat: 55, minLng: 5.5, maxLng: 15 },
            pl: { minLat: 49, maxLat: 54.5, minLng: 14, maxLng: 24 },
			vienna: { minLat: 48.15, maxLat: 48.25, minLng: 16.3, maxLng: 16.4 },
            belgrade: { minLat: 44.75, maxLat: 44.85, minLng: 20.35, maxLng: 20.55 }
        };
		
			
		function showRoundsWindow() {
            // Check if a game is in progress or not
            var gameInProgress = localStorage.getItem('gameInProgress');
            if(gameInProgress === 'true') {
                // If a game is in progress, hide the rounds window
                document.getElementById('rounds-window').style.display = 'none';
            } else {
                // If no game is in progress, show the rounds window
                document.getElementById('rounds-window').style.display = 'block';
            }
        }
		
        function updateCountry() {
             var selectedCountry = document.getElementById('country-selector').value;
    localStorage.setItem('selectedCountry', selectedCountry);
            if (selectedCountry === 'all') {
                boundingBoxes = allBoundingBoxes;
            } else {
                boundingBoxes = [countryBoundingBoxes[selectedCountry]];
            }
            fetchStreetView();  // Fetch street view for the updated country
        }

        window.onload = function() {
			initialize();
			// Load any custom boundaries from localStorage
			var storedBoundingBoxes = JSON.parse(localStorage.getItem('countryBoundingBoxes'));
			if (storedBoundingBoxes) {
				countryBoundingBoxes = storedBoundingBoxes;
				// Update the country selector with custom boundaries
				for (var boundaryId in storedBoundingBoxes) {
					var newOption = new Option(boundaryId.replace(/-/g, ' '), boundaryId);
					document.getElementById('country-selector').add(newOption);
				}
			}
		};
        function initialize() {
            fetchStreetView();
        }

        var radii = [50, 100, 500];  // Search radii in km
        var radiusIndex = 0;
        var map;  // Declare map variable

        // Define bounding boxes for the continents
        var boundingBoxes = [
            { minLat: 34, maxLat: 71, minLng: -24, maxLng: 40 },  // Europe
            { minLat: -35, maxLat: 35, minLng: -17, maxLng: 51 },  // Africa
            { minLat: 24, maxLat: 77, minLng: -169, maxLng: -50 },  // North America
            { minLat: -10, maxLat: 77, minLng: 29, maxLng: 169 },  // Asia + Australia
        ];

   async function checkLandOrWater(latLng) {
    var response = await fetch(`https://api.opencagedata.com/geocode/v1/json?q=${latLng.lat()},${latLng.lng()}&key=447586f3e798423981f62c12d8d50653`);
    var data = await response.json();
    var selectedCountry = document.getElementById('country-selector').value;
    if (data.results.length === 0 || data.results[0].components._type === 'ocean' || /ocean|sea|lake|arctic|pacific|norwegian|barents|mediterranean|gulf|aegan|tyrrhenian|atlantic/i.test(data.results[0].formatted)) {
        console.log('Generated coords found in the sea, moving to another location');
        return false;
    }
    if (selectedCountry !== 'all' && selectedCountry !== 'vienna' && selectedCountry !== 'belgrade') {
        var countryCode = data.results[0].components.country_code;
        if (countryCode !== selectedCountry) {
            console.log(`Generated coords found in ${countryCode}, moving to another location`);
            return false;
        }
    } else if (selectedCountry === 'vienna' && !data.results[0].formatted.includes('Vienna')) {
        console.log('Generated coords not found in Vienna, moving to another location');
        return false;
    } else if (selectedCountry === 'belgrade' && !data.results[0].formatted.includes('Belgrade')) {
        console.log('Generated coords not found in Belgrade, moving to another location');
        return false;
    }
    console.log(`New location is located in ${data.results[0].formatted}`);
    return true;
}

    // Add a new function to fetch and load custom boundary data
        async function loadCustomBoundary(osmId) {
            try {
                // Build the Overpass API query URL
                var query = `[out:json];(relation(${osmId}););out bb;`;
                var response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch boundary data');
                }

                var data = await response.json();
                var elements = data.elements;
                
                if (elements.length === 0 || !elements[0].bounds) {
                    throw new Error('No bounds data available for this OSM ID');
                }

                var bounds = elements[0].bounds;
                var bbox = {
                    minLat: bounds.minlat,
                    maxLat: bounds.maxlat,
                    minLng: bounds.minlon,
                    maxLng: bounds.maxlon
                };

                // Update the countryBoundingBoxes object
                countryBoundingBoxes[osmId] = bbox;

                // Add the new option to the country-selector
                var selector = document.getElementById('country-selector');
                var newOption = new Option(`OSM ID: ${osmId}`, osmId);
                selector.add(newOption);

                // Save the bounding boxes to local storage or a global variable if needed
                // For example: localStorage.setItem('countryBoundingBoxes', JSON.stringify(countryBoundingBoxes));
                // Or simply use a global variable if the persistence is not needed

                console.log(`Boundary for OSM ID: ${osmId} loaded`);
            } catch (error) {
                console.error('Error loading custom boundary:', error);
            }
        }
				
				// Example function to check if a latLng is within the custom boundary
		function isWithinCustomBoundary(latLng, boundary) {
			return (
				latLng.lat >= boundary.minLat &&
				latLng.lat <= boundary.maxLat &&
				latLng.lng >= boundary.minLng &&
				latLng.lng <= boundary.maxLng
			);
		}

 // New global variables
    var preGeneratedLocations = [];
    var usePreGeneratedLocations = false;

    // Function to pre-generate Street View locations
    async function preGenerateLocations(count) {
        for (let i = 0; i < count; i++) {
            // Call fetchStreetView and wait for it to resolve
            const location = await fetchStreetView();
            preGeneratedLocations.push(location);
        }
        // Convert the locations array to a JSON string
        const locationsString = JSON.stringify(preGeneratedLocations);
        // Trigger a download of the locations file
        const blob = new Blob([locationsString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'locations.json';
        a.click();
    }

    // Function to process uploaded locations file
    document.getElementById('locations-file-input').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (!file) {
            return;
        }
        const reader = new FileReader();
        reader.onload = function(e) {
            const contents = e.target.result;
            try {
                preGeneratedLocations = JSON.parse(contents);
                usePreGeneratedLocations = true;
                alert('Locations loaded successfully. Start the game to use them.');
            } catch (error) {
                alert('Error reading locations file.');
            }
        };
        reader.readAsText(file);
    });

async function fetchStreetView() {

   if (usePreGeneratedLocations && preGeneratedLocations.length > 0) {
            const location = preGeneratedLocations.shift(); // Use the next pre-generated location
            return new Promise(resolve => {
                processSVData({ location: location, status: google.maps.StreetViewStatus.OK });
                resolve(location); // Resolve with the location data
            });
        } else {
		
    var sv = new google.maps.StreetViewService();

    // Select the appropriate bounding box based on the user's selection
    var selectedCountry = document.getElementById('country-selector').value;
    var box;
    if (selectedCountry === 'all') {
        box = allBoundingBoxes[Math.floor(Math.random() * allBoundingBoxes.length)];
    } else {
        box = countryBoundingBoxes[selectedCountry];
    }

    // Generate a random latitude and longitude within the bounding box
    var lat = Math.random() * (box.maxLat - box.minLat) + box.minLat;
    var lng = Math.random() * (box.maxLng - box.minLng) + box.minLng;
    var latLng = new google.maps.LatLng(lat, lng);

    // Now instead of finding the closest panorama, we attempt to get a panorama directly at the random location
    sv.getPanorama({location: latLng, source: google.maps.StreetViewSource.OUTDOOR}, function(data, status) {
        if (status === google.maps.StreetViewStatus.OK) {
            // If a street view is found, set the panorama to the new location
            var panorama = new google.maps.StreetViewPanorama(
                document.getElementById('street-view'), {
                    position: data.location.latLng,
                    pov: {heading: 34, pitch: 10},
                    addressControl: false,
                    disableDefaultUI: true,
                    showRoadLabels: false
                }
            );
            initMap(data.location.latLng);
            console.log(`Street View found at ${data.location.latLng}`);
        } else {
            // If no street view is found at the random location, try again
            console.log('Street View not found at this location, trying another location...');
            fetchStreetView();
        }
    });
}
}		
		

      

async function processSVData(data, status) {
    if (status === google.maps.StreetViewStatus.OK) {
        // Snap the panorama's coordinates to the nearest road.
        var response = await fetch(`https://roads.googleapis.com/v1/snapToRoads?path=${data.location.latLng.lat()},${data.location.latLng.lng()}&key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY`);
        var roadData = await response.json();
        
        // Check if snappedPoints array has elements before trying to access its content
        if (roadData.snappedPoints && roadData.snappedPoints.length > 0) {
            // If the snapped coordinates are significantly different from the panorama's coordinates,
            // assume the panorama is not located on a road and fetch a new panorama.
            var snappedLatLng = new google.maps.LatLng(roadData.snappedPoints[0].location.latitude, roadData.snappedPoints[0].location.longitude);
            if (google.maps.geometry.spherical.computeDistanceBetween(data.location.latLng, snappedLatLng) > 50) {  // Adjust the threshold as needed.
                console.log('Panorama not located on a road, fetching a new panorama...');
                return fetchStreetView();
            }

             // Display the panorama without road names on the street
			var panorama = new google.maps.StreetViewPanorama(
				document.getElementById('street-view'),
				{
					position: data.location.latLng,
					pov: {
						heading: 34,
						pitch: 10
					},
					addressControl: false,
					disableDefaultUI: true,  // Add this line to disable the default UI
					showRoadLabels: false, // This property hides the road names on the street
					linksControl: false, // Optionally hides the arrows for navigation to other streets
					panControl: false,
					enableCloseButton: false
				}
			);


            console.log(`Pair for location found at ${data.location.latLng}`);
            initMap(data.location.latLng);
        } else {
            console.log('No roads nearby, fetching a new panorama...');
            return fetchStreetView();
        }
    } else {
        if (radiusIndex < radii.length - 1) {
            radiusIndex++;
            console.log(`Pair for location not found, finding the closest location within ${radii[radiusIndex]}km`);
            fetchStreetView();
        } else {
            console.error('Street View data not found for this location even after expanding the search radius. Retrying with a new location...');
            radiusIndex = 0;  // Reset radius index
            fetchStreetView();  // Generate a new random location
        }
    }
}


var currentRound = 0;
        var totalRounds = 0;
        var totalScore = 0;
		var timerId;
        var timeLeft;

        function startTimer(duration) {
            clearInterval(timerId);  // Clear any existing timer
            timeLeft = duration;
            document.getElementById('timer').textContent = timeLeft;
            timerId = setInterval(function() {
                timeLeft--;
                document.getElementById('timer').textContent = timeLeft;
                if(timeLeft <= 0) {
                    clearInterval(timerId);
                    timeExpired();
                }
            }, 1000);
        }

        function timeExpired() {
            console.log("Time's up! You get 0 points for this round.");
            alert("Time's up! You get 0 points for this round.");
            if (++currentRound < totalRounds) {
                fetchStreetView(); // Proceed to the next round
                var timeLimit = parseInt(document.getElementById('time-limit-input').value);
                startTimer(timeLimit);
            } else {
                endGame(); // End the game if all rounds are completed
            }
        }

  

        function startGame() {
		totalRounds = document.getElementById('rounds-input').value;
		totalScore = 0; // Reset total score
		currentRound = 0; // Reset current round
		document.getElementById('score').textContent = totalScore;
		document.getElementById('rounds-window').style.display = 'none';
		fetchStreetView(); // Fetch a new street view for the first round
		localStorage.setItem('gameInProgress', 'true'); // Indicate that a game has started
		var timeLimit = parseInt(document.getElementById('time-limit-input').value);
        startTimer(timeLimit); // Start the timer with the user-specified time limit
	}

        function calculateScore(distance) {
            // Implement the exponential scoring logic here
            // For now, let's assume it returns a score between 0 and 10000
            var score = 100000 * Math.exp(-0.000001 * distance);
            return Math.round(score);
        }

        var guessLocations = []; // To store user's guesses
        var actualLocations = []; // To store actual locations

        // This function places a marker on the map
        function placeMarker(map, location, isActual) {
            var marker = new google.maps.Marker({
                position: location,
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 5,
                    fillColor: isActual ? 'green' : 'blue',
                    fillOpacity: 1,
                    strokeColor: 'white',
                    strokeWeight: 1
                }
            });
            return marker;
        }

        // Modified version of the endGame function to include the locations summary
        function endGame() {
    document.getElementById('game-over').style.display = 'block';
    document.getElementById('total-points').textContent = totalScore;
    localStorage.setItem('gameInProgress', 'false'); // Indicate that the game has ended
    clearInterval(timerId);  // Clear the timer

    var locationsSummary = "";
    for (var i = 0; i < actualLocations.length; i++) {
        var actualName = (actualLocations[i] && actualLocations[i].name) ? actualLocations[i].name : "N/A";
        var actualCoords = (actualLocations[i] && actualLocations[i].coords) ? actualLocations[i].coords : "N/A";
        var guessName = (guessLocations[i] && guessLocations[i].name) ? guessLocations[i].name : "N/A";
        var guessCoords = (guessLocations[i] && guessLocations[i].coords) ? guessLocations[i].coords : "N/A";
        locationsSummary += "Round " + (i + 1) + ": Actual: " + actualName + ", " + actualCoords + "<br>Your guess: " + guessName + ", " + guessCoords + "<br>";
    }
    document.getElementById('locations-summary').innerHTML = locationsSummary;
}
		
  function restartGame() {
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('rounds-window').style.display = 'block';
            localStorage.setItem('gameInProgress', 'false'); // Ensure correct state is set
            showRoundsWindow(); // Show rounds window after game restart
        }
		
		        window.onload = initialize;

    
function initMap(latLng) {
    // If latLng is not provided, initialize it with a default value
    if (!latLng) {
        latLng = new google.maps.LatLng(0, 0); // Default to coordinates 0,0
    }

    // Check if the selected country is Vienna and update latLng if it is
    var selectedCountry = document.getElementById('country-selector').value;
    if (selectedCountry === 'vienna') {
        latLng = new google.maps.LatLng(48.2082, 16.3738); // Vienna's coordinates
    }

    // Initialize the map with the given or updated latLng
    map = new google.maps.Map(document.getElementById('map'), {
        center: latLng,
        zoom: selectedCountry === 'vienna' ? 10 : 1, // Zoom level 15 for Vienna, 1 otherwise
        fullscreenControl: false,
        streetViewControl: false,
        zoomControl: false,
        mapTypeControl: false,
        styles: [
            {
                featureType: "poi",
                elementType: "labels",
                stylers: [{ visibility: "off" }]
            }
        ]
    });

        // Add a click event listener to the map
        map.addListener('click', function(event) {
            if (currentRound >= totalRounds) {
                endGame();
                return;
            }

            var clickedLatLng = event.latLng;
            var distance = google.maps.geometry.spherical.computeDistanceBetween(latLng, clickedLatLng);
            var score = calculateScore(distance);
            totalScore += score;
            document.getElementById('score').textContent = totalScore;
            console.log(`Round ${currentRound + 1}/${totalRounds}: ${score} points`);

            if (++currentRound < totalRounds) {
                fetchStreetView(); // Proceed to the next round
                var timeLimit = parseInt(document.getElementById('time-limit-input').value);
                startTimer(timeLimit); // Reset the timer for the next round
            } else {
                endGame(); // End the game if all rounds are completed
            }
        });
    }
		

    </script>
	
	<script>
	function reloadLocation() {
    radiusIndex = 0;
    fetchStreetView();
}
</script>

     <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY&callback=initialize"></script>
	<button id="reload-button" onclick="reloadLocation()">reload</button>
    <div id="rounds-window">
        <label for="rounds-input">Choose number of rounds (1-20):</label>
        <input type="number" id="rounds-input" min="1" max="20" value="5">
            <label for="time-limit-input">Set time limit per round (5-600s):</label>
        <input type="number" id="time-limit-input" min="5" max="600" value="30">
        <button onclick="startGame()">Start Game</button>
    </div>

    <div id="timer-display">Time Left: <span id="timer">0</span>s</div>


    <div id="score-display">Points: <span id="score">0</span></div>

    <div id="game-over">
        <p>Game over. You won <span id="total-points">0</span> points!</p>
        <button onclick="restartGame()">Play Again</button>
    </div>
	
  <input type="text" id="osm-id-input" placeholder="Enter an OSM ID">
  <button id="load-button" onclick="loadCustomBoundary(document.getElementById('osm-id-input').value)">
    Load Boundary
  </button>

  <img id="wiesel-image" src="static/wieselspin.gif" alt="Wiesel">

	 <div id="description-text">
    <strong>Otterguesser</strong><br>
    A WIP version of geoguesser, that intends to be lightweight, better, and free.<br>
    South America is disabled out of principle.<br><br>
    <strong>Current features:</strong><br>
    - Customize number of rounds, timer, location<br>
    - Use a custom OSM ID data for custom generation boundaries<br><br>
    <strong>Future features:</strong><br>
    - Multiplayer via pregenerated locations (via .json files, generate/download/upload)<br>
    - Ability to log scores<br>
    - Logging of all generated locations (via a toggleable layer of dots on the small map, with optional .json export)<br><br>
    <strong>Current issues:</strong><br>
    - Generation within boundaries isn't precise<br>
    - Boundaries are boxes, and not exact polylines<br>
    - Slow generation of big areas, because of the issue above<br>
  </div>

</body>
</html>
