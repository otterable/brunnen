<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <title>Otterguessr | Ermine.at</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
			font-family: 'Roboto', sans-serif;
		}


        

        #street-view {
            height: 100%;
        }

    #map {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 400px; /* Initial width */
    height: 300px; /* Initial height */
    border: 2px solid black;
    border-radius: 30px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    z-index: 5;
    transition: all 0.3s ease; /* Smooth transition for size and position */
}

#map:hover {
    width: 800px; /* Increased width */
    height: 600px; /* Increased height */
    bottom: 20px; /* Adjust position to move up */
    right: 20px; /* Adjust position to move left */
}

		
		/* Hide the Street View Pegman */
.gm-svpc {
    display: none !important;
}

/* Hide the Map Type Control */
.gm-style-mtc {
    display: none !important;
}



/* Hide business POIs - Note: This might not be possible with CSS alone */


        #country-selector {
         position: relative; /* Changed to relative */
    z-index: 10;
    background: white;
    padding: 20px;
    margin-top: 20px; /* Space between the image and the window */
    border-radius: 30px;
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
}
		#reload-button {
            position: fixed;
        top: 160px; /* Adjust this if needed to clear the rounds window */
            left: 91.5%;
            transform: translateX(-50%);
            padding: 0px 3px;
            font-size: 16px;
            cursor: pointer;
			color: black !important;
            background-color: #ffffff;
            border: none;
            color: white;
            z-index: 5;
        }
		


#rounds-window {
    display: block;
    position: relative; /* Changed to relative */
    z-index: 10;
    background: white;
    padding: 20px;
    margin-top: 20px; /* Space between the image and the window */
    border-radius: 30px;
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
}
    #score-display {
        position: absolute;
        top: 90px; /* Adjusted top position */
        right: 20px;
        z-index: 5;
        background: white;
        padding: 10px;
        border-radius: 30px;
        box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }

    #game-over {
        display: none;
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 50;
        background: white;
        padding: 20px;
        border-radius: 30px;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        text-align: center;
    }

    #street-view .gm-style .gm-fullscreen-control {
        display: none !important;
    }
  
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: black;
    z-index: 10; /* High z-index to be on top */
    display: flex;
    flex-direction: column; /* Align children in a column */
    align-items: center;
    justify-content: center;
    padding: 10px; /* Add padding for spacing */
}


        #game-end-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: orange;
            z-index: 30;
            text-align: center;
            padding-top: 20%;
			opacity: 1;
        }

#rounds-window, #country-selector, #game-over, #score-display {
    font-weight: bold; /* Make the font bold */
}
#rounds-input, 
button[onclick="startGame()"] {
    border-radius: 30px;
}

button[onclick="startGame()"] {
    background-color: black;  /* Set the background to black */
    color: white;             /* Set the text color to white */
    border-radius: 30px;      /* Rounded corners */
    transition: all 0.3s ease;/* Transition effect for smooth changes */
}

button[onclick="startGame()"]:hover {
    background-color: grey;  /* Background turns green on hover */
    transform: scale(0.97);    /* Make the button larger */
}



    </style>
</head>
<body>
 <div id="loading-screen">
        <img src="static/otterguesserlogo.png" alt="OtterGuesser Logo">
	<div id="rounds-window">
        <label for="rounds-input">Choose number of rounds (1-20):</label>
        <input type="number" id="rounds-input" min="1" max="20" value="5">
        <button onclick="startGame()">Start Game</button>
    </div>
	<select id="country-selector" onchange="updateCountry()">
        <option value="all">All Countries</option>
        <option value="us">United States</option>
        <option value="fr">France</option>
        <option value="de">Germany</option>
        <option value="it">Italy</option>
        <option value="jp">Japan</option>
        <option value="ru">Russia</option>
		<option value="at">Austria</option>
        <option value="de">Germany</option>
        <option value="pl">Poland</option>
        <option value="vienna">Wien :^)</option>
        <option value="belgrade">Beograd</option>
    </select>
    </div>
    <div id="game-end-screen">
        <p>Here shall be stats.</p>
    </div>
	
<div id="round-end-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 100; align-items: center; justify-content: center; flex-direction: column;">
    <div id="result-map" style="width: 1000px; height: 800px; border-radius: 30px;"></div>
    <p id="result-text" style="color: white; font-size: 20px; margin: 20px;">You clicked at XYZ coordinates. The correct coordinates were XYZ. These locations are XYZ meters away.</p>
    <button onclick="nextRound()" style="padding: 10px 20px; font-size: 18px; cursor: pointer; border-radius: 30px;">Next Round</button>
</div>



    <div id="street-view"></div>
    <div id="map"></div>
   
    <script>
	var generatedLocations = [];
	var userClickedLocations = [];


        function initialize() {
            updateCountry();
			showRoundsWindow(); // Call this function to manage rounds window display

        }

        var radii = [50, 100, 500];  // Search radii in km
        var radiusIndex = 0;
        var map;  // Declare map variable

        // Initial bounding boxes for all continents
        var allBoundingBoxes = [
            { minLat: 34, maxLat: 71, minLng: -24, maxLng: 40 },  // Europe
            { minLat: -35, maxLat: 35, minLng: -17, maxLng: 51 },  // Africa
            { minLat: 24, maxLat: 77, minLng: -169, maxLng: -50 },  // North America
            { minLat: -10, maxLat: 77, minLng: 29, maxLng: 169 },  // Asia + Australia
        ];

        var boundingBoxes = allBoundingBoxes;  // Default bounding boxes

        // Country-specific bounding boxes
        var countryBoundingBoxes = {
            us: { minLat: 24, maxLat: 49, minLng: -125, maxLng: -66 },
            fr: { minLat: 41, maxLat: 51, minLng: -5, maxLng: 8 },
            de: { minLat: 47, maxLat: 55, minLng: 5, maxLng: 15 },
            it: { minLat: 35, maxLat: 47, minLng: 6, maxLng: 19 },
            jp: { minLat: 30, maxLat: 45, minLng: 129, maxLng: 146 },
            ru: { minLat: 41, maxLat: 81, minLng: 19, maxLng: 169 },
			at: { minLat: 46.4, maxLat: 49, minLng: 9.5, maxLng: 17 },
            de: { minLat: 47, maxLat: 55, minLng: 5.5, maxLng: 15 },
            pl: { minLat: 49, maxLat: 54.5, minLng: 14, maxLng: 24 },
			vienna: { minLat: 48.15, maxLat: 48.25, minLng: 16.3, maxLng: 16.4 },
            belgrade: { minLat: 44.75, maxLat: 44.85, minLng: 20.35, maxLng: 20.55 }
        };
		
		function showRoundsWindow() {
            // Check if a game is in progress or not
            var gameInProgress = localStorage.getItem('gameInProgress');
            if(gameInProgress === 'true') {
                // If a game is in progress, hide the rounds window
                document.getElementById('rounds-window').style.display = 'none';
            } else {
                // If no game is in progress, show the rounds window
                document.getElementById('rounds-window').style.display = 'block';
            }
        }
		

function updateCountry() {
    var selectedCountry = document.getElementById('country-selector').value;
    localStorage.setItem('selectedCountry', selectedCountry);
    if (selectedCountry === 'all') {
        boundingBoxes = allBoundingBoxes;
    } else {
        boundingBoxes = [countryBoundingBoxes[selectedCountry]];
    }
    // Do NOT call fetchStreetView() here
}

        window.onload = function() {
    document.getElementById('loading-screen').style.display = 'flex';

    var selectedCountry = localStorage.getItem('selectedCountry');
    if (selectedCountry) {
        document.getElementById('country-selector').value = selectedCountry;
        updateCountry(); // Only update country selection, don't fetch Street View
    }
};
        function initialize() {
        }

        var radii = [50, 100, 500];  // Search radii in km
        var radiusIndex = 0;
        var map;  // Declare map variable

        // Define bounding boxes for the continents
        var boundingBoxes = [
            { minLat: 34, maxLat: 71, minLng: -24, maxLng: 40 },  // Europe
            { minLat: -35, maxLat: 35, minLng: -17, maxLng: 51 },  // Africa
            { minLat: 24, maxLat: 77, minLng: -169, maxLng: -50 },  // North America
            { minLat: -10, maxLat: 77, minLng: 29, maxLng: 169 },  // Asia + Australia
        ];

   async function checkLandOrWater(latLng) {
    var response = await fetch(`https://api.opencagedata.com/geocode/v1/json?q=${latLng.lat()},${latLng.lng()}&key=447586f3e798423981f62c12d8d50653`);
    var data = await response.json();
    var selectedCountry = document.getElementById('country-selector').value;
    if (data.results.length === 0 || data.results[0].components._type === 'ocean' || /ocean|sea|lake|arctic|pacific|norwegian|barents|mediterranean|gulf|aegan|tyrrhenian|atlantic/i.test(data.results[0].formatted)) {
        console.log('Generated coords found in the sea, moving to another location');
        return false;
    }
    if (selectedCountry !== 'all' && selectedCountry !== 'vienna' && selectedCountry !== 'belgrade') {
        var countryCode = data.results[0].components.country_code;
        if (countryCode !== selectedCountry) {
            console.log(`Generated coords found in ${countryCode}, moving to another location`);
            return false;
        }
    } else if (selectedCountry === 'vienna' && !data.results[0].formatted.includes('Vienna')) {
        console.log('Generated coords not found in Vienna, moving to another location');
        return false;
    } else if (selectedCountry === 'belgrade' && !data.results[0].formatted.includes('Belgrade')) {
        console.log('Generated coords not found in Belgrade, moving to another location');
        return false;
    }
    console.log(`New location is located in ${data.results[0].formatted}`);
    return true;
}

async function fetchCustomBoundary() {
    var townName = document.getElementById('custom-boundary-input').value;
    if (!townName) {
        console.error('Please enter a town name.');
        return;
    }
    
    try {
        var response = await fetch(`https://example.com/geojson-boundaries/${encodeURIComponent(townName)}`);
        if (!response.ok) {
            console.error('Failed to fetch GeoJSON boundaries:', response.statusText);
            return;
        }

        var geojsonData = await response.json();
        var bbox = geojsonData.bbox;
        if (!bbox || bbox.length !== 4) {
            console.error('Invalid GeoJSON bounding box data:', bbox);
            return;
        }

        boundingBoxes = [{
            minLat: bbox[1],
            maxLat: bbox[3],
            minLng: bbox[0],
            maxLng: bbox[2]
        }];
        fetchStreetView();  // Fetch street view for the custom boundary

    } catch (error) {
        console.error('Error fetching or processing GeoJSON boundaries:', error);
    }
}


async function fetchStreetView() {
    var sv = new google.maps.StreetViewService();
    // Generate random coordinates within the defined bounding boxes
    var box = boundingBoxes[Math.floor(Math.random() * boundingBoxes.length)];
    var lat = Math.random() * (box.maxLat - box.minLat) + box.minLat;
    var lng = Math.random() * (box.maxLng - box.minLng) + box.minLng;
    var latLng = new google.maps.LatLng(lat, lng);

    var isLand = await checkLandOrWater(latLng);
    if (!isLand) {
        return fetchStreetView();
    }

    sv.getPanorama({
        location: latLng,
        radius: radii[radiusIndex] * 1000,  // Search radius around the random point
        source: google.maps.StreetViewSource.OUTDOOR // Focus on outdoor imagery
    }, function(data, status) {
        if (status === google.maps.StreetViewStatus.OK) {
            // Check if there are links (indicating navigable paths)
            if (data.links && data.links.length > 0) {
                processSVData(data, status);
            } else {
                // If no links, it's likely a static spot, fetch another location
                console.log('Static spot found, fetching a new location...');
                fetchStreetView();
            }
        } else {
            console.log('Street View not found, retrying...');
            fetchStreetView();
        }
    });
}

		
		

async function processSVData(data, status) {
    if (status === google.maps.StreetViewStatus.OK) {
        // Snap the panorama's coordinates to the nearest road.
        var response = await fetch(`https://roads.googleapis.com/v1/snapToRoads?path=${data.location.latLng.lat()},${data.location.latLng.lng()}&key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY`);
        var roadData = await response.json();
        
        // Check if snappedPoints array has elements before trying to access its content
        if (roadData.snappedPoints && roadData.snappedPoints.length > 0) {
            // If the snapped coordinates are significantly different from the panorama's coordinates,
            // assume the panorama is not located on a road and fetch a new panorama.
var snappedLatLng = new google.maps.LatLng(roadData.snappedPoints[0].location.latitude, roadData.snappedPoints[0].location.longitude);
generatedLocations.push(snappedLatLng); // Store the generated location
if (google.maps.geometry.spherical.computeDistanceBetween(data.location.latLng, snappedLatLng) > 50) {  // Adjust the threshold as needed.
                console.log('Panorama not located on a road, fetching a new panorama...');
                return fetchStreetView();
            }

            // Otherwise, display the panorama and the map.
            var panorama = new google.maps.StreetViewPanorama(
                document.getElementById('street-view'),
                {
                    position: data.location.latLng,
                    pov: {
                        heading: 34,
                        pitch: 10
                    },
                    addressControl: false,
					showRoadLabels: false  // Hide road labels
                });
            console.log(`Pair for location found at ${data.location.latLng}`);
            initMap(data.location.latLng);
        } else {
            console.log('No roads nearby, fetching a new panorama...');
            return fetchStreetView();
        }
    } else {
        if (radiusIndex < radii.length - 1) {
            radiusIndex++;
            console.log(`Pair for location not found, finding the closest location within ${radii[radiusIndex]}km`);
            fetchStreetView();
        } else {
            console.error('Street View data not found for this location even after expanding the search radius. Retrying with a new location...');
            radiusIndex = 0;  // Reset radius index
            fetchStreetView();  // Generate a new random location
        }
    }
}



var currentRound = 0;
        var totalRounds = 0;
        var totalScore = 0;

function startGame() {
    document.getElementById('loading-screen').style.display = 'none';
    document.getElementById('country-selector').style.display = 'none';
    totalRounds = document.getElementById('rounds-input').value;
    totalScore = 0;
    currentRound = 0;
    document.getElementById('score').textContent = totalScore;
    document.getElementById('rounds-window').style.display = 'none';
    localStorage.setItem('gameInProgress', 'true');

    fetchStreetView(); // Add this to start generating Street View locations
}

        function calculateScore(distance) {
            // Implement the exponential scoring logic here
            // For now, let's assume it returns a score between 0 and 10000
            var score = 10000 * Math.exp(-0.000001 * distance);
            return Math.round(score);
        }

async function getLocationName(latLng) {
    var response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${latLng.lat()},${latLng.lng()}&key=YOUR_API_KEY`);
    var data = await response.json();
    return data.results[0]?.formatted_address || "Unknown location";
}

async function endGame() {
    var resultsHtml = "<h3>Game Results</h3><ul>";

    // Create a map to display user-guessed and correct locations
    var map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 0, lng: 0 },
        zoom: 2
    });

    for (var i = 0; i < generatedLocations.length; i++) {
        var genLoc = generatedLocations[i];
        var userLoc = userClickedLocations[i];
        if (!genLoc || !userLoc) {
            console.error("Invalid location data at round", i + 1);
            continue; // Skip this round
        }

        var genLocName = await getLocationName(genLoc);
        var userLocName = await getLocationName(userLoc);
        var distance = calculateDistance(genLoc.lat(), genLoc.lng(), userLoc.lat(), userLoc.lng());

        resultsHtml += `<li>Round ${i + 1}: 
            Generated Location - <a href="https://www.google.com/maps/search/?api=1&query=${genLoc.lat()},${genLoc.lng()}" target="_blank">${genLocName}</a> (${genLoc.lat().toFixed(5)}, ${genLoc.lng().toFixed(5)}), 
            Your Guess - <a href="https://www.google.com/maps/search/?api=1&query=${userLoc.lat()},${userLoc.lng()}" target="_blank">${userLocName}</a> (${userLoc.lat().toFixed(5)}, ${userLoc.lng().toFixed(5)}), 
            Distance Off: ${distance.toFixed(2)} km</li>`;

        // Add markers with circles on the map
        var userMarker = new google.maps.Marker({
            position: userLoc,
            map: map,
            label: {
                text: (i + 1).toString(), // Round number
                color: '#000000', // Text color
                fontWeight: 'bold', // Make text bold
                fontSize: '14px' // Text size
            },
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 10,
                fillColor: "#FF0000",
                fillOpacity: 0.4,
                strokeWeight: 1
            }
        });

        var correctMarker = new google.maps.Marker({
            position: genLoc,
            map: map,
            label: {
                text: (i + 1).toString(), // Round number
                color: '#000000', // Text color
                fontWeight: 'bold', // Make text bold
                fontSize: '14px' // Text size
            },
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 10,
                fillColor: "#00FF00",
                fillOpacity: 0.4,
                strokeWeight: 1
            }
        });
    }

    resultsHtml += "</ul>";
    document.getElementById('game-end-screen').innerHTML = resultsHtml;
    document.getElementById('game-over').style.display = 'block';
    document.getElementById('total-points').textContent = totalScore;
    localStorage.setItem('gameInProgress', 'false'); // Indicate that the game has ended
    document.getElementById('game-end-screen').style.display = 'block'; // Show game end screen
    document.getElementById('map-container').style.display = 'block'; // Show the map container
}

document.getElementById('game-end-screen').addEventListener('click', function() {
    this.style.display = 'none';  // Hide the game-over screen
    document.getElementById('loading-screen').style.display = 'flex'; // Show the loading screen
    document.getElementById('map-container').style.display = 'none'; // Hide the map container when game results are closed
});

function restartGame() {
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('rounds-window').style.display = 'block';
    localStorage.setItem('gameInProgress', 'false'); // Ensure correct state is set
    showRoundsWindow(); // Show rounds window after game restart
}






      document.getElementById('game-end-screen').addEventListener('click', function() {
	  this.style.display = 'none';  // Hide the game-over screen
      document.getElementById('loading-screen').style.display = 'flex'; // Show the loading screen
});

        function restartGame() {
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('rounds-window').style.display = 'block';
            localStorage.setItem('gameInProgress', 'false'); // Ensure correct state is set
            showRoundsWindow(); // Show rounds window after game restart
        }
		
		        window.onload = initialize;


function initMap() {
    var fixedLatLng = new google.maps.LatLng(48.8566, 2.3522); // Example fixed coordinates (Paris, France)

    var mapOptions = {
        center: fixedLatLng,       // Fixed center for the map
        zoom: 2,                  // Fixed zoom level
        fullscreenControl: false,  // Keep the fullscreen control disabled
        zoomControl: false,        // Disable zoom controls
        streetViewControl: false,  // Disable Street View Pegman
        mapTypeControl: false,     // Disable map type (satellite/normal) control
        styles: [{                 // Style to hide business POIs (if needed)
            featureType: "poi.business",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
        }]
    };

    map = new google.maps.Map(document.getElementById('map'), mapOptions);

    // Add a click event listener to the map
map.addListener('click', function(event) {
    if (currentRound >= totalRounds) {
        endGame();
        return;
    }

    var clickedLatLng = event.latLng;
    userClickedLocations.push(clickedLatLng); // Store the user clicked location
    var generatedLatLng = generatedLocations[currentRound]; // The correct location for the current round

    endRound(clickedLatLng, generatedLatLng); // Show the results overlay

    // Increment round and update score here, but don't fetch new Street View yet
    var score = calculateScore(google.maps.geometry.spherical.computeDistanceBetween(generatedLatLng, clickedLatLng));
    totalScore += score;
    document.getElementById('score').textContent = totalScore;
    currentRound++;
});

}

		function calculateDistance(lat1, lng1, lat2, lng2) {
    var earthRadiusKm = 6371;

    var dLat = degreesToRadians(lat2-lat1);
    var dLng = degreesToRadians(lng2-lng1);

    lat1 = degreesToRadians(lat1);
    lat2 = degreesToRadians(lat2);

    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.sin(dLng/2) * Math.sin(dLng/2) * Math.cos(lat1) * Math.cos(lat2); 
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
    return earthRadiusKm * c;
}

function degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
}

function endRound(userLatLng, correctLatLng) {
    var distance = calculateDistance(userLatLng.lat(), userLatLng.lng(), correctLatLng.lat(), correctLatLng.lng());
    document.getElementById('result-text').innerText = `You clicked at (${userLatLng.lat().toFixed(5)}, ${userLatLng.lng().toFixed(5)}). The correct coordinates were (${correctLatLng.lat().toFixed(5)}, ${correctLatLng.lng().toFixed(5)}). These locations are ${Math.round(distance)} meters away.`;

    displayResultMap(userLatLng, correctLatLng);
    document.getElementById('round-end-overlay').style.display = 'flex';
}

function nextRound() {
    document.getElementById('round-end-overlay').style.display = 'none';
    fetchStreetView();
}

function displayResultMap(userLatLng, correctLatLng) {
    var map = new google.maps.Map(document.getElementById('result-map'), {
        center: userLatLng,
        zoom: 2 // Set the zoom level to 1
    });

    new google.maps.Marker({
        position: userLatLng,
        map: map,
        label: {
            text: 'Your Otterguess', // Text for the label
            color: '#000000', // Text color
            fontWeight: 'bold', // Make text bold
            fontSize: '14px' // Text size
        },
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 10,
            fillColor: "#FF0000",
            fillOpacity: 0.4,
            strokeWeight: 1
        }
    });

    new google.maps.Marker({
        position: correctLatLng,
        map: map,
        label: {
            text: 'Actual location', // Text for the label
            color: '#000000', // Text color
            fontWeight: 'bold', // Make text bold
            fontSize: '14px' // Text size
        },
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 10,
            fillColor: "#00FF00",
            fillOpacity: 0.4,
            strokeWeight: 1
        }
    });
}

async function getLocationName(latLng) {
    var response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${latLng.lat()},${latLng.lng()}&key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY`);
	var data = await response.json();
    
    if (data.results.length > 0) {
        var result = data.results[0];
        var addressComponents = result.address_components;
        var locality = addressComponents.find(c => c.types.includes('locality'))?.long_name;
        var adminArea = addressComponents.find(c => c.types.includes('administrative_area_level_1'))?.long_name;
        var country = addressComponents.find(c => c.types.includes('country'))?.long_name;

        var address = [locality, adminArea, country].filter(Boolean).join(", ");
        return address || result.formatted_address;
    } else {
        return "Unknown location";
    }
}


async function endRound(userLatLng, correctLatLng) {
    var userLocationName = await getLocationName(userLatLng);
    var correctLocationName = await getLocationName(correctLatLng);
    var distance = calculateDistance(userLatLng.lat(), userLatLng.lng(), correctLatLng.lat(), correctLatLng.lng());

		document.getElementById('result-text').innerHTML = `
        You clicked at <a href="https://www.google.com/maps/search/?api=1&query=${userLatLng.lat()},${userLatLng.lng()}" target="_blank" style="color: white; font-weight: bold;">${userLocationName}</a>. 
        The correct location was <a href="https://www.google.com/maps/search/?api=1&query=${correctLatLng.lat()},${correctLatLng.lng()}" target="_blank" style="color: white; font-weight: bold;">${correctLocationName}</a>. 
        These locations are ${Math.round(distance)} meters away.`;

    displayResultMap(userLatLng, correctLatLng);
    document.getElementById('round-end-overlay').style.display = 'flex';
}


		
    </script>
	
	<script>
	function reloadLocation() {
    radiusIndex = 0;
    fetchStreetView();
}
</script>

    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY&callback=initialize"></script>
	<button id="reload-button" onclick="reloadLocation()">reload</button>
  

    <div id="score-display">Points: <span id="score">0</span></div>

    <div id="game-over">
        <p>Game over. You won <span id="total-points">0</span> points!</p>
        <button onclick="restartGame()">Play Again</button>
    </div>
</body>
</html>