<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoGuessr Clone</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #street-view {
            height: 100%;
        }
		
		    #street-view .gm-style .gm-fullscreen-control {
        display: none !important;
    }

        #map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            border: 2px solid black;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 5;
        }

        #country-selector {
            position: absolute;
            bottom: 330px;
            right: 20px;
            z-index: 5;
        }
		
		#reload-button {
            position: fixed;
        top: 160px; /* Adjust this if needed to clear the rounds window */
            left: 91.5%;
            transform: translateX(-50%);
            padding: 0px 3px;
            font-size: 16px;
            cursor: pointer;
			color: black !important;
            background-color: #ffffff;
            border: none;
            color: white;
            z-index: 10;
        }
		

    #rounds-window {
            display: block; /* Changed from none to block */
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

    #score-display {
        position: absolute;
        top: 90px; /* Adjusted top position */
        right: 20px;
        z-index: 10;
        background: white;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }

    #game-over {
        display: none;
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 20;
        background: white;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        text-align: center;
    }

  

    </style>
</head>
<body>
    <div id="street-view"></div>
    <div id="map"></div>
    <input type="file" id="geojson-file" accept=".json" onchange="loadGeoJSONFile(event)">

    <script>
           function initialize() {
            fetchStreetView();
            showRoundsWindow(); // Manage rounds window display
        }

         function loadGeoJSONFile(event) {
            const fileReader = new FileReader();
            fileReader.onload = function(event) {
                try {
                    const geojsonData = JSON.parse(event.target.result);
                    boundingBoxes = geojsonData.features.map(feature => {
                        const bounds = feature.geometry.coordinates[0][0].reduce(
                            (bounds, coord) => {
                                return {
                                    minLat: Math.min(bounds.minLat, coord[1]),
                                    maxLat: Math.max(bounds.maxLat, coord[1]),
                                    minLng: Math.min(bounds.minLng, coord[0]),
                                    maxLng: Math.max(bounds.maxLng, coord[0])
                                };
                            }, 
                            { minLat: Infinity, maxLat: -Infinity, minLng: Infinity, maxLng: -Infinity }
                        );
                        return bounds;
                    });
                    fetchStreetView(); // Fetch street view using the loaded bounding boxes
                } catch (error) {
                    console.error('Could not parse the GeoJSON file:', error);
                }
            };
            fileReader.onerror = function() {
                console.error('FileReader error.');
            };
            fileReader.readAsText(event.target.files[0]);
        }
		
		
		// Sample GeoJSON object
const geoJson = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "id": "relation/6590353",
      "properties": {
        // ... properties
      },
      "geometry": {
        "type": "MultiPolygon",
        "coordinates": [
          [
            [
              [-57.476248, -25.1050462],
              // ... other coordinates
            ]
          ]
        ]
      }
    }
    // ... other features
  ]
};

function isValidCoordinate(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
}

function extractValidCoordinates(geoJson) {
  if (geoJson.type === 'FeatureCollection' && Array.isArray(geoJson.features)) {
    for (let feature of geoJson.features) {
      if (feature.geometry && feature.geometry.type === 'MultiPolygon') {
        for (let polygon of feature.geometry.coordinates) {
          for (let coordinates of polygon) {
            for (let coordinatePair of coordinates) {
              let [longitude, latitude] = coordinatePair;
              if (isValidCoordinate(latitude) && isValidCoordinate(longitude)) {
                // Valid coordinates found, you can now use these to make an API call
                console.log(`Valid coordinates found: ${latitude}, ${longitude}`);
                // Call your function to fetch Street View data here
                // fetchStreetView(latitude, longitude);
                return; // Exit after first valid coordinates are found
              }
            }
          }
        }
      }
    }
  }
  console.error('No valid coordinates found in the provided GeoJSON object.');
}

extractValidCoordinates(geoJson);

        var radii = [50, 100, 500];  // Search radii in km
        var radiusIndex = 0;
        var map;  // Declare map variable

        // Initial bounding boxes for all continents
        var allBoundingBoxes = [
            { minLat: 34, maxLat: 71, minLng: -24, maxLng: 40 },  // Europe
            { minLat: -35, maxLat: 35, minLng: -17, maxLng: 51 },  // Africa
            { minLat: 24, maxLat: 77, minLng: -169, maxLng: -50 },  // North America
            { minLat: -10, maxLat: 77, minLng: 29, maxLng: 169 },  // Asia + Australia
        ];

        var boundingBoxes = allBoundingBoxes;  // Default bounding boxes

        // Country-specific bounding boxes
        var countryBoundingBoxes = {
            us: { minLat: 24, maxLat: 49, minLng: -125, maxLng: -66 },
            fr: { minLat: 41, maxLat: 51, minLng: -5, maxLng: 8 },
            de: { minLat: 47, maxLat: 55, minLng: 5, maxLng: 15 },
            it: { minLat: 35, maxLat: 47, minLng: 6, maxLng: 19 },
            jp: { minLat: 30, maxLat: 45, minLng: 129, maxLng: 146 },
            ru: { minLat: 41, maxLat: 81, minLng: 19, maxLng: 169 },
			at: { minLat: 46.4, maxLat: 49, minLng: 9.5, maxLng: 17 },
            de: { minLat: 47, maxLat: 55, minLng: 5.5, maxLng: 15 },
            pl: { minLat: 49, maxLat: 54.5, minLng: 14, maxLng: 24 },
			vienna: { minLat: 48.15, maxLat: 48.25, minLng: 16.3, maxLng: 16.4 },
            belgrade: { minLat: 44.75, maxLat: 44.85, minLng: 20.35, maxLng: 20.55 }
        };
		
		function showRoundsWindow() {
            // Check if a game is in progress or not
            var gameInProgress = localStorage.getItem('gameInProgress');
            if(gameInProgress === 'true') {
                // If a game is in progress, hide the rounds window
                document.getElementById('rounds-window').style.display = 'none';
            } else {
                // If no game is in progress, show the rounds window
                document.getElementById('rounds-window').style.display = 'block';
            }
        }
		
		
		
        function updateCountry() {
            var selectedCountry = document.getElementById('country-selector').value;
            localStorage.setItem('selectedCountry', selectedCountry);
            if (selectedCountry === 'all') {
                boundingBoxes = allBoundingBoxes;
            } else {
                boundingBoxes = [countryBoundingBoxes[selectedCountry]];
            }
            fetchStreetView();  // Fetch street view for the updated country
        }

        window.onload = function() {
            var selectedCountry = localStorage.getItem('selectedCountry');
            if (selectedCountry) {
                document.getElementById('country-selector').value = selectedCountry;
                updateCountry();
            } else {
                fetchStreetView();  // Fetch street view if no country is selected
            }
        };
        function initialize() {
            fetchStreetView();
        }

        var radii = [50, 100, 500];  // Search radii in km
        var radiusIndex = 0;
        var map;  // Declare map variable

        // Define bounding boxes for the continents
        var boundingBoxes = [
            { minLat: 34, maxLat: 71, minLng: -24, maxLng: 40 },  // Europe
            { minLat: -35, maxLat: 35, minLng: -17, maxLng: 51 },  // Africa
            { minLat: 24, maxLat: 77, minLng: -169, maxLng: -50 },  // North America
            { minLat: -10, maxLat: 77, minLng: 29, maxLng: 169 },  // Asia + Australia
        ];



async function fetchCustomBoundary() {
    var townName = document.getElementById('custom-boundary-input').value;
    if (!townName) {
        console.error('Please enter a town name.');
        return;
    }
    
    try {
        var response = await fetch(`https://example.com/geojson-boundaries/${encodeURIComponent(townName)}`);
        if (!response.ok) {
            console.error('Failed to fetch GeoJSON boundaries:', response.statusText);
            return;
        }

        var geojsonData = await response.json();
        var bbox = geojsonData.bbox;
        if (!bbox || bbox.length !== 4) {
            console.error('Invalid GeoJSON bounding box data:', bbox);
            return;
        }

        boundingBoxes = [{
            minLat: bbox[1],
            maxLat: bbox[3],
            minLng: bbox[0],
            maxLng: bbox[2]
        }];
        fetchStreetView();  // Fetch street view for the custom boundary

    } catch (error) {
        console.error('Error fetching or processing GeoJSON boundaries:', error);
    }
}


             async function fetchStreetView() {
            var sv = new google.maps.StreetViewService();
            // Generate random coordinates within the defined bounding boxes
            var box = boundingBoxes[Math.floor(Math.random() * boundingBoxes.length)];
            var lat = Math.random() * (box.maxLat - box.minLat) + box.minLat;
            var lng = Math.random() * (box.maxLng - box.minLng) + box.minLng;
            var latLng = new google.maps.LatLng(lat, lng);

            console.log(`Location ${latLng} generated, finding the closest location within ${radii[radiusIndex]}km`);
            sv.getPanorama({
                location: latLng,
                radius: radii[radiusIndex] * 1000,
                source: google.maps.StreetViewSource.OUTDOOR
            }, processSVData);  // Convert km to meters
        }

		
		

async function processSVData(data, status) {
    if (status === google.maps.StreetViewStatus.OK) {
        // Snap the panorama's coordinates to the nearest road.
        var response = await fetch(`https://roads.googleapis.com/v1/snapToRoads?path=${data.location.latLng.lat()},${data.location.latLng.lng()}&key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY`);
        var roadData = await response.json();
        
        // Check if snappedPoints array has elements before trying to access its content
        if (roadData.snappedPoints && roadData.snappedPoints.length > 0) {
            // If the snapped coordinates are significantly different from the panorama's coordinates,
            // assume the panorama is not located on a road and fetch a new panorama.
            var snappedLatLng = new google.maps.LatLng(roadData.snappedPoints[0].location.latitude, roadData.snappedPoints[0].location.longitude);
            if (google.maps.geometry.spherical.computeDistanceBetween(data.location.latLng, snappedLatLng) > 50) {  // Adjust the threshold as needed.
                console.log('Panorama not located on a road, fetching a new panorama...');
                return fetchStreetView();
            }

            // Otherwise, display the panorama and the map.
            var panorama = new google.maps.StreetViewPanorama(
                document.getElementById('street-view'),
                {
                    position: data.location.latLng,
                    pov: {
                        heading: 34,
                        pitch: 10
                    },
                    addressControl: false
                });
            console.log(`Pair for location found at ${data.location.latLng}`);
            initMap(data.location.latLng);
        } else {
            console.log('No roads nearby, fetching a new panorama...');
            return fetchStreetView();
        }
    } else {
        if (radiusIndex < radii.length - 1) {
            radiusIndex++;
            console.log(`Pair for location not found, finding the closest location within ${radii[radiusIndex]}km`);
            fetchStreetView();
        } else {
            console.error('Street View data not found for this location even after expanding the search radius. Retrying with a new location...');
            radiusIndex = 0;  // Reset radius index
            fetchStreetView();  // Generate a new random location
        }
    }
}


var currentRound = 0;
        var totalRounds = 0;
        var totalScore = 0;

        function startGame() {
		totalRounds = document.getElementById('rounds-input').value;
		totalScore = 0; // Reset total score
		currentRound = 0; // Reset current round
		document.getElementById('score').textContent = totalScore;
		document.getElementById('rounds-window').style.display = 'none';
		fetchStreetView(); // Fetch a new street view for the first round
		localStorage.setItem('gameInProgress', 'true'); // Indicate that a game has started
	}

        function calculateScore(distance) {
            // Implement the exponential scoring logic here
            // For now, let's assume it returns a score between 0 and 10000
            var score = 100000 * Math.exp(-0.000001 * distance);
            return Math.round(score);
        }

        function endGame() {
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('total-points').textContent = totalScore;
            localStorage.setItem('gameInProgress', 'false'); // Indicate that the game has ended
        }

        function restartGame() {
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('rounds-window').style.display = 'block';
            localStorage.setItem('gameInProgress', 'false'); // Ensure correct state is set
            showRoundsWindow(); // Show rounds window after game restart
        }
		
		        window.onload = initialize;


        // Overwrite the initMap function to handle scoring
       function initMap(latLng) {
        map = new google.maps.Map(document.getElementById('map'), {
            center: {lat: 0, lng: 0}, // Center the map over the coordinates 0,0
            zoom: 1,  // Set zoom level for world view
            fullscreenControl: false  // This line disables the fullscreen control
        });


    // Add a click event listener to the map
    map.addListener('click', function(event) {
                if (currentRound >= totalRounds) {
                    endGame();
                    return;
                }

                var clickedLatLng = event.latLng;
                var distance = google.maps.geometry.spherical.computeDistanceBetween(latLng, clickedLatLng);
                var score = calculateScore(distance);
                totalScore += score;
                document.getElementById('score').textContent = totalScore;
                console.log(`Round ${currentRound + 1}/${totalRounds}: ${score} points`);

                if (++currentRound < totalRounds) {
                    fetchStreetView(); // Proceed to the next round
                } else {
                    endGame(); // End the game if all rounds are completed
                }
            });
        }
		
		
    </script>
	
	<script>
	function reloadLocation() {
    radiusIndex = 0;
    fetchStreetView();
}
</script>

    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY&callback=initialize"></script>
	<button id="reload-button" onclick="reloadLocation()">reload</button>
    <div id="rounds-window">
        <label for="rounds-input">Choose number of rounds (1-20):</label>
        <input type="number" id="rounds-input" min="1" max="20" value="5">
            <label for="time-limit-input">Set time limit per round (5-600s):</label>
        <input type="number" id="time-limit-input" min="5" max="600" value="30">
        <button onclick="startGame()">Start Game</button>
    </div>

    <div id="timer-display">Time Left: <span id="timer">0</span>s</div>


    <div id="score-display">Points: <span id="score">0</span></div>

    <div id="game-over">
        <p>Game over. You won <span id="total-points">0</span> points!</p>
        <button onclick="restartGame()">Play Again</button>
    </div>
</body>
</html>
