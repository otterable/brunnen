<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <title>Otterguessr | Ermine.at</title>
    <style>
    html, body {
            height: 100%;
            margin: 0;
            padding: 0;
			font-family: 'Roboto', sans-serif;
		}




        #street-view {
            height: 100%;
        }

        #toggle-streetview-movement {
    background-color: #ffffff; /* Green background */
    color: black; /* White text */
    padding: 10px; /* Padding for size */
    text-align: center; /* Centered text */
    text-decoration: none; /* No underline */
    display: inline-block; /* Inline block display */
    font-size: 16px; /* Font size */
    margin-top: 10px; /* Margin around the button */
    cursor: pointer; /* Cursor changes to pointer on hover */
    border-radius: 30px; /* Rounded corners */
}
#admin-settings-text {
    color: white;
}

 #map {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 400px; /* Initial width */
    height: 300px; /* Initial height */
    border: 2px solid black;
    border-radius: 30px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    z-index: 5;
    transition: all 0.3s ease; /* Smooth transition for size and position */
}

#map:hover {
    width: 800px; /* Increased width */
    height: 600px; /* Increased height */
    bottom: 20px; /* Adjust position to move up */
    right: 20px; /* Adjust position to move left */
}

/* Mobile-specific styles */
@media screen and (max-width: 768px) {
    #map {
        width: 100%; /* Full width of the screen */
        height: 300px; /* Set a fixed height */
        bottom: 0; /* Align to the bottom of the screen */
        right: 0; /* Align to the right of the screen */
        border-radius: 0; /* Optional: remove border-radius for full-width */
        box-shadow: none; /* Optional: remove box-shadow for a cleaner look */
    }

    #map:hover {
        width: 100%; /* Maintain full width on hover */
        height: 300px; /* Maintain height on hover */
		    right: 0px; /* Adjust position to move left */
			    bottom: 0px; /* Adjust position to move up */


    }
}



                /* Hide the Street View Pegman */
.gm-svpc {
}

/* Hide the Map Type Control */
.gm-style-mtc {
    display: none !important;
}

/* Button style for toggling the map on mobile */
#map-toggle-button {
    position: fixed;
    top: 150px;
    right: 10px;
    border: none;
    background: transparent;
    padding: 5px;
    border-radius: 50px;
    display: none; /* Hidden by default, will be displayed on mobile */
    z-index: 2; /* Ensure it's above other elements */
}

#map-toggle-button img {
    width: 40px;
border-radius: 50px;
    height: 40px; /* Adjust size as needed */
}

/* Hide the map by default on mobile devices */
@media screen and (max-width: 768px) {
    #map {
        display: none;
    }

    #map-toggle-button {
        display: block;
    }
}

/* Hide business POIs - Note: This might not be possible with CSS alone */


        #country-selector {
         position: relative; /* Changed to relative */
    z-index: 10;
    background: white;
    padding: 10px;
    margin-top: 10px; /* Space between the image and the window */
    border-radius: 30px;
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
}
                #reload-button {
            position: fixed;
        top: 160px; /* Adjust this if needed to clear the rounds window */
            left: 91.5%;
            transform: translateX(-50%);
            padding: 0px 3px;
            font-size: 16px;
            cursor: pointer;
                        color: black !important;
            background-color: #ffffff;
            border: none;
            color: white;
            z-index: 5;
        }



#rounds-window {
    display: block;
    position: relative; /* Changed to relative */
    z-index: 10;
    background: white;
    padding: 10px;
    margin-top: 10px; /* Space between the image and the window */
    border-radius: 30px;
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
}

#generic-pill {
    display: block;
    position: relative; /* Changed to relative */
    z-index: 10;
    background: white;
    padding: 10px;
    margin-top: 10px; /* Space between the image and the window */
    border-radius: 30px;
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
}
    #score-display {
        position: absolute;
        top: 90px; /* Adjusted top position */
        right: 20px;
        z-index: 5;
        background: white;
        padding: 10px;
        border-radius: 30px;
        box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }


#rounds-window {
    display: flex; /* Use flexbox for alignment */
    justify-content: center; /* Center items horizontally in the container */
    align-items: center; /* Align items vertically in the middle */
    gap: 10px; /* Add some space between elements */
}

#rounds-window label,
#rounds-window input,
#rounds-window button {
    margin: 0; /* Remove default margin */
}


/* Default Styles (for larger screens) */
#round-end-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 100;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

#result-map {
    width: 1000px;
    height: 700px;
    border-radius: 30px;
}

#result-text {
    color: white;
    font-size: 20px;
    margin: 20px;
}


#timer-duration-label,
#enable-movement-label,
#same-location-for-all-label {
    color: white;
}

#round-end-button {
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
    border-radius: 30px;
}

/* Mobile-specific styles */
@media screen and (max-width: 768px) {
    #result-map {
        width: 98% !important; /* Adjust width to be a percentage of the screen */
		top: 1%;
        height: auto; /* Adjust height to maintain aspect ratio */
        max-width: 700px; /* Optional: set a max-width if needed */
    }


    #result-text {
        font-size: 16px; /* Adjust font size for smaller screens */
        padding: 0 10px; /* Add padding to keep the text within the viewport */
    }

   #round-end-button {
           font-size: 16px; /* Adjust font size for smaller screens */
margin-bottom: 10px !important; 
        bottom: 1% !important;
    }
}


#game-over {
    display: none;
    position: absolute;
    bottom: 20px; /* Position from the bottom */
    right: 20px; /* Position from the right */
    z-index: 50;
    background: white;
    padding: 20px;
    border-radius: 30px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    text-align: center;
}


@media screen and (min-width: 768px) {
    #close-game-results {
	        display: none; /* Hide the button by default */
}
}

/* Mobile-specific styles */
@media screen and (max-width: 768px) {
    #close-game-results {
        position: absolute; /* Position the button absolutely within its parent */
        bottom: 3%; /* 1% from the bottom edge of the parent container */
        left: 50%; /* Center the button horizontally */
        transform: translateX(-50%); /* Adjust for exact centering */
        display: none; /* Hide the button by default */
        padding: 5px 10px; /* Padding inside the button */
        font-size: 16px; /* Font size of the button text */
        border-radius: 10px; /* Rounded corners */
        border: none; /* No border */
        background-color: rgba(76, 175, 80, 0.8); /* Semi-transparent background color */
        color: white; /* Text color */
        cursor: pointer; /* Pointer cursor on hover */
        text-align: center; /* Center the text inside the button */
		z-index: 51;
    }
}





/* Mobile-specific styles */
@media screen and (max-width: 768px) {
    #game-over {
	   top: 1%; /* Position the game-over container at the top with 1% gap */
        bottom: auto; /* Reset the bottom value */
        width: 90%; /* Adjust width to fit the mobile screen */
        margin: 0 auto; /* Center the divs on the screen */
        left: 0; /* Align to the left edge */
        right: 0; /* Align to the right edge */
        transform: translateX(0); /* Reset any translations */
    }

 #game-results {
        width: 90%; /* Set the width to a percentage of the screen */
        max-width: 90%; /* Ensure it doesn't exceed the screen width */
        margin: 0 auto; /* Center it horizontally */
        padding: 10px; /* Add some padding for spacing */
        box-sizing: border-box; /* Include padding in the width calculation */
        text-align: center; /* Center text inside the container */
        bottom: 1%; /* Maintain the position at the bottom with 1% gap */
        top: auto; /* Reset the top value */
        left: 0 !important; /* Align to the left edge */
        right: 0; /* Align to the right edge */
    }
    #gameover-map {
        width: 100%; /* Ensure the map takes up the full width of its container */
        max-width: 100%; /* Prevent the map from exceeding the container's width */
        height: auto; /* Adjust the height to maintain the aspect ratio */
        margin-top: 20px; /* Keep the existing top margin */
    }
}
#game-results {
    display: none;
    position: absolute;
    bottom: 20px; /* Position from the bottom */
    left: 20px; /* Position from the left */
    background: white;
    padding: 20px;
    border-radius: 30px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    z-index: 50; /* Ensure it's above other elements */
    max-height: 800px; /* Set a maximum height */
    overflow-y: auto; /* Enable scrolling if content overflows */
    max-width: 1000px; /* Set a width for the results */
}


    #street-view .gm-style .gm-fullscreen-control {
        display: none !important;
    }

.overlay {
    position: fixed; /* Stay in place */
    z-index: 10000; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    background-color: rgba(0,0,0,0.2); /* Black background with 0.2 opacity */
    display: flex; /* Use Flexbox to center the child */
    align-items: center; /* Align vertically at center */
    justify-content: center; /* Align horizontally at center */
    overflow-y: auto; /* Enable scroll if needed */
}

#custom-location-editor {
    background-color: #000000;
    padding: 20px;
    width: 80%; /* Could be more or less, depending on screen size */
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); /* Optional: adds a subtle shadow for better visibility */
}
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: black;
    z-index: 10; /* High z-index to be on top */
    display: flex;
    flex-direction: column; /* Align children in a column */
    align-items: center;
    justify-content: center;
    padding: 10px; /* Add padding for spacing */
	overflow-y: auto;
}


        #game-end-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: orange;
            z-index: 30;
            text-align: center;
            padding-top: 20%;
                        opacity: 1;
        }

                 .styled-window {
            display: block;
            position: relative; /* Changed to relative */
            z-index: 10;
            background: white;
            padding: 10px;
            margin-top: 10px; /* Space between the image and the window */
            border-radius: 30px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }


#rounds-window, #country-selector, #game-over, #score-display {
    font-weight: bold; /* Make the font bold */
}

* Adjustments for mobile screens */
@media screen and (max-width: 768px) {
    #loading-screen {
        padding: 5px; /* Reduced padding */
    }

    .smaller-image {
        width: 50%; /* Larger width for the logo image */
    }

    #rounds-window, #timer-settings, .styled-window, #country-selector, #server-viewing, #server-creation, #multiplayer-game-creation {
        width: 95%; /* Use more screen width */
        margin: 5px 0; /* Smaller vertical spacing */
    }
	}
#rounds-input,
button[onclick="startGame()"] {
    border-radius: 30px;
}

#rounds-input,
button[onclick="startGame()"],
#num-rounds,
#timer-duration {
    border-radius: 30px;
}


.no-rooms-message {
    color: black; /* Sets the text color to black */
}

button[onclick="startGame()"] {
    background-color: black;  /* Set the background to black */
    color: white;             /* Set the text color to white */
    border-radius: 30px;      /* Rounded corners */
    transition: all 0.3s ease;/* Transition effect for smooth changes */
}

button[onclick="startGame()"]:hover {
    background-color: grey;  /* Background turns green on hover */
    transform: scale(0.97);    /* Make the button larger */
}

#play-again-button {
    background-color: black; /* Set the background to black */
        margin-top:5px;
    color: white;            /* Set the text color to white */
    border-radius: 30px;     /* Rounded corners */
    transition: all 0.3s ease;/* Transition effect for smooth changes */
}

#play-again-button:hover {
    background-color: grey; /* Background turns grey on hover */
    transform: scale(0.97); /* Make the button larger */
}

    .smaller-image {
            width: 20%; /* Adjust the width as needed */
            height: auto; /* Keeps the aspect ratio intact */
        }

#timer-settings {
    font-weight: bold;
}

        .styled-button {
            background-color: black;  /* Set the background to black */
            color: white;             /* Set the text color to white */
            border-radius: 30px;      /* Rounded corners */
            transition: all 0.3s ease;/* Transition effect for smooth changes */
        }

        .styled-button:hover {
            background-color: grey;  /* Background turns grey on hover */
            transform: scale(0.97);  /* Make the button slightly larger */
        }
		
		 .styled-buttonwhite {
            background-color: white;  /* Set the background to black */
            color: black;             /* Set the text color to white */
            border-radius: 30px;      /* Rounded corners */
            transition: all 0.3s ease;/* Transition effect for smooth changes */
        }

        .styled-buttonwhite:hover {
            background-color: grey;  /* Background turns grey on hover */
            transform: scale(0.97);  /* Make the button slightly larger */
        }
		
		
		
		

    </style>
</head>
<body>
 <div id="loading-screen">
         <img src="static/otterguesserlogo.png" alt="OtterGuesser Logo" class="smaller-image">


<button id="classic-mode-button" class="styled-window" onclick="toggleClassicMode()">Classic Mode - - randomly generated locations</button>
<div id="classic-mode-settings" style="display: none;">
                      
					  <div id="rounds-window">
        <label for="rounds-input">Choose number of rounds (1-50):</label>
        <input type="number" id="rounds-input" min="1" max="50" value="5">
        <button onclick="startGame()">Start Game</button>
    </div>
<div id="timer-settings" class="styled-window">
    <label for="timer-duration">Set timer duration (10s to 1200s). Currently <span id="current-timer-duration" style="color: green;">120</span>s</label>
    <input type="number" style="border-radius: 30px;" id="timer-duration" min="10" max="1200" value="120">
    <button onclick="setTimerDuration()" class="styled-button">Set Timer</button>
</div>
        <select id="country-selector" onchange="updateCountry()">
        <option value="all">All Countries</option>
        <option value="us">United States</option>
        <option value="fr">France</option>
        <option value="de">Germany</option>
        <option value="it">Italy</option>
        <option value="jp">Japan</option>
        <option value="ru">Russia</option>
                <option value="at">Austria</option>
        <option value="de">Germany</option>
        <option value="pl">Poland</option>
        <option value="vienna">Wien :^)</option>
        <option value="belgrade">Beograd</option>
    </select>
    <!-- Existing content -->
    <button id="toggle-streetview-movement" onclick="toggleStreetViewMovement()">Enable/Disable Movement</button>
    <span id="movement-status" style="color: green;">Movement Enabled</span>
</div>


<button id="custom-mode-button" class="styled-window" onclick="toggleCustomMode()">Custom Mode - pregenerated locations from a file</button>
<div id="custom-mode-settings" style="display: none;">
<div class="styled-window">
    <input type="file" id="file-input" />
    <button onclick="loadGameFromFile()">Load Game from File</button>
</div>
</div>


<button id="launch-custom-mode"  class="styled-window"  onclick="launchCustomGenerationMode()">Launch custom mode editor</button>


<button id="online-multiplayer-button" class="styled-window" onclick="toggleOnlineMultiplayer()">Online Multiplayer</button>
<div id="online-multiplayer-settings" style="display: none;">

<div id="pregenerate-settings" class="styled-window">
    <label for="pregenerate-rounds-input">Pregenerate Rounds:</label>
    <input type="number" id="pregenerate-rounds-input" min="1" max="50" value="5">
    <button onclick="pregenerateRounds()">Pregenerate</button>
</div>

<!-- Loading Overlay for Pregeneration -->
<div id="loading-pregeneration-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 100; align-items: center; justify-content: center;">
    <img src="static/wieselspin.gif" alt="Loading...">
</div>


<input type="text" id="nickname" style="display:none;" placeholder="Enter your nickname">

<div class="styled-window">
<div id="server-viewing">
    <div id="server-list" style="color:white"></div>
    <div id="server-creation">
        <input type="text" id="server-name" style="display:none" placeholder="Enter server name">
        <button onclick="joinOrCreateGame()" class="styled-button">Create / Join Server</button>
    </div>
</div>

 </div>


<div id="player-list" class="player-list" style="color:white"></div>
 
   <div id="chat-window" style="display: none; position: fixed; bottom: 0; right: 0; width: 300px; height: 200px; background-color: #fff; z-index: 50000;">
    <!-- Chat messages will be displayed here -->
</div>


<!-- Additional HTML for Multiplayer Game Creation -->
<div id="multiplayer-game-creation" style="display: block;">
<p id="admin-settings-text">Online Multiplayer - Admin settings</p>
    <input type="number" id="num-rounds" placeholder="Choose number of rounds (1-50)">
 <label id="timer-duration-label">
    <input type="number" id="timer-duration" placeholder="Set timer duration (10s to 1200s)">
</label>
<label id="enable-movement-label">
    <input type="checkbox" id="enable-movement">
    Enable/Disable Movement
</label>
<label id="same-location-for-all-label">
    <input type="checkbox" id="same-location-for-all">
    Same location for all players
</label>
	
    <button id="start-multiplayer-game">Start Multiplayer Game</button>
</div>
<!-- Add a placeholder for multiplayer game alerts -->
<div id="multiplayer-alert" style="display: none;"></div>


	
	
  </div>
<div id="game-start-announcement" style="display: none;">A game is about to start. Get ready for the Otterguessr!</div>

  <!-- Placeholder for multiplayer game alerts -->
  <div id="multiplayer-alert"></div>
  
  <span style="color: white;">v12.12.2023e, f_otterguessr_a17</span>
<a href="https://ko-fi.com/otterable" target="_blank">
    <img height="36" style="border:0px;height:20px; display:none" src="static/donate.png" border="0" alt="Support on Ko-fi" />
</a>
</div>



<div id="custom-location-editor" class="overlay" style="display: none;">
    <span style="color: white;">
        <h4>Welcome to the editor! Press "Show guide" to see how this all works. Have fun!</h4>
        <p>Current timer length: <span id="custom-timer-display" style="color: green;">120</span> seconds</p>
        <p>Movement: <span id="custom-movement-status" style="color: green;">Enabled</span></p>
        <p>Saved locations: <span id="custom-location-count">0</span></p>
    </span>
    <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 10px;">

        <button onclick="saveLocation()">Save location (create round)</button>
        <div>
            <input type="number" id="custom-timer-input" value="120" min="10" max="1200">
            <button onclick="setCustomRoundTimerLength()">Set round length</button>
        </div>
                <button id="toggle-movement-button" onclick="toggleCustomMovement()">Enable/Disable Movement</button>
        <button onclick="showGuide()">Show Guide</button>
        <button id="download-custom-file" onclick="downloadCustomLocationsFile()" style="display: block;">Download custom mode!</button>
        <button onclick="toggleCustomGenerationMode()">Close editor</button>
    </div>
    <div id="custom-map" style="width: 1000px; height: 700px;"></div>
</div>


    </div>
    <div id="game-end-screen">
        <p>Here shall be stats.</p>
    </div>

        <div id="loading-icon" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index:10000">
    <img src="static/wieselspin.gif" alt="Loading...">
        </div>


<div id="round-end-overlay">
    <div id="result-map" style="width: 1000px; height: 700px; border-radius: 30px;"></div>
    <p id="result-text" style="color: white; font-size: 20px; margin: 20px;">You clicked at XYZ coordinates. The correct coordinates were XYZ. These locations are XYZ kilometers away.</p>
<button id="round-end-button" onclick="nextRound()" style="padding: 10px 20px; font-size: 18px; cursor: pointer; border-radius: 30px;">Continue</button>
</div>

<div id="round-number-display" style="position: absolute; top: 20px; right: 20px; background: white; padding: 10px; border-radius: 30px; box-shadow: 0 0 5px rgba(0,0,0,0.3); z-index: 5;">
    Round: <span id="round-number">0</span> / <span id="total-rounds">0</span>
</div>


    <div id="timer-display" style="position: absolute; top: 20px; left: 20px; background: white; padding: 10px; border-radius: 30px; box-shadow: 0 0 5px rgba(0,0,0,0.3); z-index: 5;">
        Time left: <span id="timer">--:--</span>
    </div>


<button id="map-toggle-button" onclick="toggleMapDisplay()">
    <img src="static/mapicon_mobile.png" alt="Toggle Map">
</button>


    <div id="street-view"></div>
    <div id="map"></div>

    <script>



        function initialize() {
            updateCountry();
                        showRoundsWindow(); // Call this function to manage rounds window display

        }

                function loadGameFromFile() {
    var fileInput = document.getElementById('file-input');
    var file = fileInput.files[0];
    if (!file) {
        console.error('No file selected.');
        return;
    }

    var reader = new FileReader();
    reader.onload = function(e) {
        var contents = e.target.result;
        try {
            var data = JSON.parse(contents);
            setupGameFromFile(data);
        } catch (error) {
            console.error('Error parsing JSON:', error);
        }
    };
    reader.readAsText(file);
}

function setupGameFromFile(data) {
    if (data.totalRounds && data.roundLength && data.locations) {
        // Set total rounds and round length
        document.getElementById('rounds-input').value = data.totalRounds;
        document.getElementById('timer-duration').value = data.roundLength;
        timePerRound = data.roundLength;

        // Set locations for the game
        generatedLocations = data.locations.map(loc => new google.maps.LatLng(loc.lat, loc.lng));

        // Check and set Street View movement status
        if (data.hasOwnProperty('movementEnabled')) {
            allowStreetViewMovement = data.movementEnabled;
            console.log(`Movement in the loaded file is ${allowStreetViewMovement ? 'enabled' : 'disabled'}.`);
        } else {
            console.log("Movement status not specified in the file. Defaulting to enabled.");
            allowStreetViewMovement = true;
        }

        console.log(`File ${data.randomFileName} loaded. Timer is ${data.roundLength} seconds, there are ${data.totalRounds} rounds, the locations are:`);
        data.locations.forEach((loc, index) => console.log(`Round ${index + 1}: ${loc.lat}, ${loc.lng}`));

        startGame(); // Start the game with loaded settings
    } else {
        console.error('Invalid game data from file.');
    }
}


        var radii = [50, 100, 500];  // Search radii in km
        var radiusIndex = 0;
        var map;  // Declare map variable

        // Initial bounding boxes for all continents
        var allBoundingBoxes = [
            { minLat: 34, maxLat: 71, minLng: -24, maxLng: 40 },  // Europe
            { minLat: -35, maxLat: 35, minLng: -17, maxLng: 51 },  // Africa
            { minLat: 24, maxLat: 77, minLng: -169, maxLng: -50 },  // North America
            { minLat: -10, maxLat: 77, minLng: 29, maxLng: 169 },  // Asia + Australia
        ];

        var boundingBoxes = allBoundingBoxes;  // Default bounding boxes

        // Country-specific bounding boxes
        var countryBoundingBoxes = {
            us: { minLat: 24, maxLat: 49, minLng: -125, maxLng: -66 },
            fr: { minLat: 41, maxLat: 51, minLng: -5, maxLng: 8 },
            de: { minLat: 47, maxLat: 55, minLng: 5, maxLng: 15 },
            it: { minLat: 35, maxLat: 47, minLng: 6, maxLng: 19 },
            jp: { minLat: 30, maxLat: 45, minLng: 129, maxLng: 146 },
            ru: { minLat: 41, maxLat: 81, minLng: 19, maxLng: 169 },
                        at: { minLat: 46.4, maxLat: 49, minLng: 9.5, maxLng: 17 },
            de: { minLat: 47, maxLat: 55, minLng: 5.5, maxLng: 15 },
            pl: { minLat: 49, maxLat: 54.5, minLng: 14, maxLng: 24 },
                        vienna: { minLat: 48.15, maxLat: 48.25, minLng: 16.3, maxLng: 16.4 },
            belgrade: { minLat: 44.75, maxLat: 44.85, minLng: 20.35, maxLng: 20.55 }
        };

                function showRoundsWindow() {
            // Check if a game is in progress or not
            var gameInProgress = localStorage.getItem('gameInProgress');
            if(gameInProgress === 'true') {
                // If a game is in progress, hide the rounds window
                document.getElementById('rounds-window').style.display = 'none';
            } else {
                // If no game is in progress, show the rounds window
                document.getElementById('rounds-window').style.display = 'block';
            }
        }


function updateCountry() {
    var selectedCountry = document.getElementById('country-selector').value;
    localStorage.setItem('selectedCountry', selectedCountry);
    if (selectedCountry === 'all') {
        boundingBoxes = allBoundingBoxes;
    } else {
        boundingBoxes = [countryBoundingBoxes[selectedCountry]];
    }
    // Do NOT call fetchStreetView() here
}

        window.onload = function() {
    document.getElementById('loading-screen').style.display = 'flex';

    var selectedCountry = localStorage.getItem('selectedCountry');
    if (selectedCountry) {
        document.getElementById('country-selector').value = selectedCountry;
        updateCountry(); // Only update country selection, don't fetch Street View
    }
};
        function initialize() {
        }

        var radii = [50, 100, 500];  // Search radii in km
        var radiusIndex = 0;
        var map;  // Declare map variable

        // Define bounding boxes for the continents
        var boundingBoxes = [
            { minLat: 34, maxLat: 71, minLng: -24, maxLng: 40 },  // Europe
            { minLat: -35, maxLat: 35, minLng: -17, maxLng: 51 },  // Africa
            { minLat: 24, maxLat: 77, minLng: -169, maxLng: -50 },  // North America
            { minLat: -10, maxLat: 77, minLng: 29, maxLng: 169 },  // Asia + Australia
        ];

async function checkLandOrWater(latLng) {
    const nominatimUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latLng.lat()}&lon=${latLng.lng()}`;
    const response = await fetch(nominatimUrl, {
        headers: { 'User-Agent': 'YourAppName/YourEmail' } // Replace with your app name and email
    });
    const data = await response.json();
    const selectedCountry = document.getElementById('country-selector').value;

    if (!data || !data.address || /ocean|sea|lake|arctic|pacific|norwegian|barents|mediterranean|gulf|aegan|tyrrhenian|atlantic/i.test(data.display_name)) {
        console.log('Generated coords found in the sea, moving to another location');
        return false;
    }

    if (selectedCountry !== 'all' && selectedCountry !== 'vienna' && selectedCountry !== 'belgrade') {
        const countryCode = data.address.country_code;
        if (countryCode !== selectedCountry) {
            console.log(`Generated coords found in ${countryCode}, moving to another location`);
            return false;
        }
    } else if (selectedCountry === 'vienna' && !data.display_name.includes('Vienna')) {
        console.log('Generated coords not found in Vienna, moving to another location');
        return false;
    } else if (selectedCountry === 'belgrade' && !data.display_name.includes('Belgrade')) {
        console.log('Generated coords not found in Belgrade, moving to another location');
        return false;
    }

    console.log(`New location is located in ${data.display_name}`);
    return true;
}


async function fetchCustomBoundary() {
    var townName = document.getElementById('custom-boundary-input').value;
    if (!townName) {
        console.error('Please enter a town name.');
        return;
    }

    try {
        var response = await fetch(`https://example.com/geojson-boundaries/${encodeURIComponent(townName)}`);
        if (!response.ok) {
            console.error('Failed to fetch GeoJSON boundaries:', response.statusText);
            return;
        }

        var geojsonData = await response.json();
        var bbox = geojsonData.bbox;
        if (!bbox || bbox.length !== 4) {
            console.error('Invalid GeoJSON bounding box data:', bbox);
            return;
        }

        boundingBoxes = [{
            minLat: bbox[1],
            maxLat: bbox[3],
            minLng: bbox[0],
            maxLng: bbox[2]
        }];
        fetchStreetView();  // Fetch street view for the custom boundary

    } catch (error) {
        console.error('Error fetching or processing GeoJSON boundaries:', error);
    }
}



async function fetchStreetView() {
    if (!isGameActive) {
        console.log('Game has ended. No new Street View will be fetched.');
        return; // Exit the function if the game is not active
    }

    // Hide the map at the start of each round on mobile devices
    if (window.innerWidth <= 768) {
        document.getElementById('map').style.display = 'none';
    }

    if (generatedLocations && generatedLocations.length > currentRound) {
        let latLng = generatedLocations[currentRound];
        if (latLng && typeof latLng.lat === 'function' && typeof latLng.lng === 'function') {
            // Valid location, proceed to show Street View
            showStreetView(latLng);
        } else {
            console.error('Invalid location in generatedLocations:', latLng);
            // Handle invalid location (e.g., fetch a new one or skip the round)
        }
        return;
    }
    console.log("Fetching Street View for round:", currentRound + 1);
	if (window.innerWidth > 768) { // Assuming 768px as a breakpoint for desktop devices
        document.getElementById('map').style.display = 'block';
    }
    document.getElementById('loading-icon').style.display = 'block';  // Show loading icon
    console.log("Game loading, wieselspin added");
    var sv = new google.maps.StreetViewService();
    // Generate random coordinates within the defined bounding boxes
    var box = boundingBoxes[Math.floor(Math.random() * boundingBoxes.length)];
    var lat = Math.random() * (box.maxLat - box.minLat) + box.minLat;
    var lng = Math.random() * (box.maxLng - box.minLng) + box.minLng;
    var latLng = new google.maps.LatLng(lat, lng);

    var isLand = await checkLandOrWater(latLng);
    if (!isLand) {
        return fetchStreetView();
    }

    sv.getPanorama({
        location: latLng,
        radius: radii[radiusIndex] * 1000,  // Search radius around the random point
        source: google.maps.StreetViewSource.OUTDOOR // Focus on outdoor imagery
    }, function(data, status) {
        if (status === google.maps.StreetViewStatus.OK) {
            // Check if there are links (indicating navigable paths)
            if (data.links && data.links.length > 0) {
                processSVData(data, status);
            } else {
                // If no links, it's likely a static spot, fetch another location
                console.log('Static spot found, fetching a new location...');
                fetchStreetView();
            }
        } else {
            console.log('Street View not found, retrying...');
            fetchStreetView();
        }
    });
}
function showStreetView(latLng) {
    var sv = new google.maps.StreetViewService();
    sv.getPanorama({
        location: latLng,
        radius: 50,  // Adjust this radius if needed
        source: google.maps.StreetViewSource.OUTDOOR
    }, function(data, status) {
        if (status === google.maps.StreetViewStatus.OK) {
            var panoramaOptions = {
                position: latLng,
                pov: { heading: 34, pitch: 10 },
                addressControl: false,
                showRoadLabels: false,
                clickToGo: allowStreetViewMovement, // Use the global variable
                scrollwheel: allowStreetViewMovement, // Disable scrolling
                linksControl: allowStreetViewMovement  // Disable navigation arrows
            };
            var panorama = new google.maps.StreetViewPanorama(
                document.getElementById('street-view'), panoramaOptions);
            startTimer();
            initMap(data.location.latLng);
        } else {
            console.error('Street View not found for the given location.');
        }
    });
}



                var timer;
        var timePerRound = 120; // Default time per round in seconds

function setTimerDuration() {
    var newDuration = parseInt(document.getElementById('timer-duration').value);
    if (newDuration >= 10 && newDuration <= 1200) {
        timePerRound = newDuration;
        console.log('Timer duration set to:', timePerRound); // Debugging
        document.getElementById('current-timer-duration').textContent = timePerRound; // Update the displayed timer duration
        alert('Timer duration set to ' + timePerRound + ' seconds.'); // Popup message
    } else {
        alert('Please enter a duration between 10 and 1200 seconds.');
    }
}



        function startTimer() {
                    if (!isGameActive) {
        console.log('Game has ended. Timer will not start.');
        return; // Exit the function if the game is not active
    }
            var timeLeft = timePerRound;
            document.getElementById('timer').textContent = formatTime(timeLeft);
            timer = setInterval(function() {
                timeLeft--;
                document.getElementById('timer').textContent = formatTime(timeLeft);
                console.log('Timer updated:', formatTime(timeLeft)); // Debugging

                if (timeLeft <= 0) {
                    clearInterval(timer);
                    console.log('Time is up! Moving to the next round.'); // Debugging
                    endRoundEarly();
                }
            }, 1000);
        }

        function formatTime(seconds) {
            var min = Math.floor(seconds / 60);
            var sec = seconds % 60;
            return min.toString().padStart(2, '0') + ':' + sec.toString().padStart(2, '0');
        }

        function endRoundEarly() {
            if (currentRound < totalRounds - 1) {
                currentRound++;
                updateRoundNumberDisplay();
                fetchStreetView();
            } else {
                endGame();
            }
            alert('You get 0 points for this round!');
            document.getElementById('score').textContent = totalScore;
        }


var allowStreetViewMovement = true; // Global variable to control Street View movement

function toggleStreetViewMovement() {
    allowStreetViewMovement = !allowStreetViewMovement;
    console.log('Street View movement ' + (allowStreetViewMovement ? 'enabled' : 'disabled'));

    var statusText = allowStreetViewMovement ? 'enabled' : 'disabled';
    var statusColor = allowStreetViewMovement ? 'green' : 'red';

    document.getElementById('movement-status').textContent = `Movement ${statusText}`;
    document.getElementById('movement-status').style.color = statusColor;

    alert('Street View movement has been ' + statusText + '.');
}




async function processSVData(data, status) {
    if (status === google.maps.StreetViewStatus.OK) {
        // Snap the panorama's coordinates to the nearest road.
        var response = await fetch(`https://roads.googleapis.com/v1/snapToRoads?path=${data.location.latLng.lat()},${data.location.latLng.lng()}&key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY`);
        var roadData = await response.json();

        // Check if snappedPoints array has elements before trying to access its content
        if (roadData.snappedPoints && roadData.snappedPoints.length > 0) {
            // If the snapped coordinates are significantly different from the panorama's coordinates,
            // assume the panorama is not located on a road and fetch a new panorama.
var snappedLatLng = new google.maps.LatLng(roadData.snappedPoints[0].location.latitude, roadData.snappedPoints[0].location.longitude);
generatedLocations.push(snappedLatLng); // Store the generated location
if (google.maps.geometry.spherical.computeDistanceBetween(data.location.latLng, snappedLatLng) > 50) {  // Adjust the threshold as needed.
                console.log('Panorama not located on a road, fetching a new panorama...');
                return fetchStreetView();
            }

            // Otherwise, display the panorama and the map.
           var panoramaOptions = {
        position: data.location.latLng,
        pov: { heading: 34, pitch: 10 },
        addressControl: false,
        showRoadLabels: false,
        clickToGo: allowStreetViewMovement,
        scrollwheel: allowStreetViewMovement,
        linksControl: allowStreetViewMovement
    };
    var panorama = new google.maps.StreetViewPanorama(document.getElementById('street-view'), panoramaOptions);
            console.log('Pair for location found at', data.location.latLng); // Debugging
            startTimer();
            initMap(data.location.latLng);
        } else {
            console.log('No roads nearby, fetching a new panorama...');
            return fetchStreetView();
        }
    } else {
        if (radiusIndex < radii.length - 1) {
            radiusIndex++;
            console.log(`Pair for location not found, finding the closest location within ${radii[radiusIndex]}km`);
            fetchStreetView();
        } else {
            console.error('Street View data not found for this location even after expanding the search radius. Retrying with a new location...');
            radiusIndex = 0;  // Reset radius index
            fetchStreetView();  // Generate a new random location
        }
    }
                                gameData.locations.push({ // Save location data
                lat: data.location.latLng.lat(),
                lng: data.location.latLng.lng()
            });
                          document.getElementById('loading-icon').style.display = 'none';
                          console.log("Streetview found (location saved), wieselspin hidden."); // Debugging log
              console.log('Location saved:', gameData.locations[gameData.locations.length - 1]); // Debugging
        }



var currentRound = 0;
        var totalRounds = 0;
        var totalScore = 0;


function updateRoundNumberDisplay() {
    document.getElementById('round-number').textContent = currentRound + 1; // +1 because rounds start at 0
    document.getElementById('total-rounds').textContent = totalRounds;
}

var generatedLocations = [];
var userClickedLocations = [];
var isGameActive = false; // New variable to track the game state


       var gameData = {
                locations: [],
                randomFileName: '',
                totalRounds: 0,
                roundLength: 0,
                streetViewMovementEnabled: true // New property to store Street View movement status
        };

        function generateRandomFileName() {
            var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            var fileName = '';
            for (var i = 0; i < 16; i++) {
                fileName += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return fileName + '.json';
        }

        function saveGameData() {
    var blob = new Blob([JSON.stringify(gameData)], { type: 'application/json' });
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = gameData.randomFileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    console.log('Game data saved to file:', gameData.randomFileName);
    console.log('Street View movement in the saved game was ' + (gameData.streetViewMovementEnabled ? 'enabled' : 'disabled'));
}



function startGame() {
    currentRound = 0; 
    isGameActive = true; // Set to true when a new game starts
    roundScores = []; // Reset the round scores for the new game
    if (!generatedLocations || generatedLocations.length === 0) {
        generatedLocations = []; // Reset generated locations only if none are preloaded
        gameData.randomFileName = generateRandomFileName(); // Generate random file name
        console.log('Game started with random locations.');
    } else {
        console.log(`Game started with preloaded locations from file ${gameData.randomFileName}. No file will be generated.`);
        gameData.randomFileName = ''; // Clear the randomFileName to disable file generation
    }
	
	if (window.innerWidth > 768) { // Assuming 768px as a breakpoint for desktop devices
        document.getElementById('map').style.display = 'block';
    }
    userClickedLocations = []; // Reset user clicked locations for new game
    totalRounds = document.getElementById('rounds-input').value; // Set totalRounds before updating the display
    currentRound = 0; // Reset currentRound to 0
    totalScore = 0;
    updateRoundNumberDisplay(); // Update the round number display
    document.getElementById('score').textContent = totalScore;
    document.getElementById('game-results').style.display = 'none';
    document.getElementById('game-results').innerHTML = ''; // Reset game results content
    document.getElementById('loading-screen').style.display = 'none';
    document.getElementById('country-selector').style.display = 'none';
    document.getElementById('rounds-window').style.display = 'none';
    localStorage.setItem('gameInProgress', 'true');
    gameData.totalRounds = totalRounds; // Store total rounds
    gameData.roundLength = timePerRound; // Store round length
    console.log('Total rounds:', gameData.totalRounds, 'Round length:', gameData.roundLength); // Debugging

    // Hide map at the beginning of every round on mobile
    if (window.innerWidth <= 768) {
        document.getElementById('close-game-results').style.display = 'none';
        document.getElementById('map').style.display = 'none';
    }

    fetchStreetView();
}


var roundScores = []; // Global array to store scores for each round

function calculateScore(distance) {
    var score = 10000 * Math.exp(-0.000001 * distance);
    console.log("Calculated score: " + score + " for distance: " + distance);
    var roundedScore = Math.round(score);
    roundScores.push(roundedScore); // Store the rounded score for later use
    return roundedScore;
}




async function endGame() {
    isGameActive = false; // Set to false when the game ends
    clearInterval(timer); // Clear the timer
    timer = null; // Reset the timer variable
    var resultsHtml = "<h3>Game Results</h3><ul>";

    // Update the map rendering part
    var map = new google.maps.Map(document.getElementById('gameover-map'), {
        center: { lat: 0, lng: 0 },
        zoom: 2
    });

   for (var i = 0; i < generatedLocations.length; i++) {
        var genLoc = generatedLocations[i];
        var userLoc = userClickedLocations[i];
        if (!genLoc || !userLoc) {
            console.error("Invalid location data at round", i + 1);
            continue; // Skip this round
        }

        var genLocName = await getLocationName(genLoc);
        var userLocName = await getLocationName(userLoc);
        var distance = calculateDistance(genLoc.lat(), genLoc.lng(), userLoc.lat(), userLoc.lng());
        var score = roundScores[i]; // Retrieve the stored score

        console.log("Round " + (i + 1) + " - Calculated score: " + score + ", Distance: " + distance.toFixed(2) + " km");

        resultsHtml += `<li>Round ${i + 1}:
            ✔️: <a href="https://www.google.com/maps/search/?api=1&query=${genLoc.lat()},${genLoc.lng()}" target="_blank">${genLocName}</a>,
            ❌: <a href="https://www.google.com/maps/search/?api=1&query=${userLoc.lat()},${userLoc.lng()}" target="_blank">${userLocName}</a>,
            📏: ${distance.toFixed(2)} km, 💯: ${score} points</li>`;


        // Add markers with circles on the map
        var userMarker = new google.maps.Marker({
            position: userLoc,
            map: map,
            label: {
                text: (i + 1).toString(), // Round number
                color: '#000000', // Text color
                fontWeight: 'bold', // Make text bold
                fontSize: '14px' // Text size
            },
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 10,
                fillColor: "#FF0000",
                fillOpacity: 0.4,
                strokeWeight: 1
            }
        });

        var correctMarker = new google.maps.Marker({
            position: genLoc,
            map: map,
            label: {
                text: (i + 1).toString(), // Round number
                color: '#000000', // Text color
                fontWeight: 'bold', // Make text bold
                fontSize: '14px' // Text size
            },
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 10,
                fillColor: "#00FF00",
                fillOpacity: 0.4,
                strokeWeight: 1
            }
        });
    }



   resultsHtml += "</ul>";
    document.getElementById('game-results').innerHTML = resultsHtml;
    document.getElementById('score-display').style.display = 'block';
    document.getElementById('game-over').style.display = 'block';
	    document.getElementById('map').style.display = 'none';
    document.getElementById('game-results').style.display = 'block';
    document.getElementById('total-points').textContent = totalScore;
	if (window.innerWidth <= 768) {
        document.getElementById('close-game-results').style.display = 'block';
    }
	
    localStorage.setItem('gameInProgress', 'false');

    // Save the Street View movement status
    gameData.streetViewMovementEnabled = allowStreetViewMovement;
    console.log('Game ended with total score: ' + totalScore);
    console.log('Street View movement was ' + (allowStreetViewMovement ? 'enabled' : 'disabled'));

updateScoreboard();
    console.log('All players have finished playing. SCORES ARE FINAL.');


    // Save game data to a file if started with randomly generated locations
        if (gameData.randomFileName) {
        gameData.locations = generatedLocations;
        saveGameData(); // Save the game data to a file
        console.log('Game data saved to file:', gameData.randomFileName); // Debugging
    } else {
        console.log('Game started with preloaded locations, no file will be downloaded.');
    }




   // Reset game data and generated locations
    generatedLocations = [];
    gameData = { locations: [], randomFileName: '', totalRounds: 0, roundLength: 0 };
    console.log('Game ended, data cache deleted.'); // Debugging message


}
document.getElementById('game-end-screen').addEventListener('click', function() {
    this.style.display = 'none';
    document.getElementById('loading-screen').style.display = 'flex';
});

window.onload = function() {
    initialize();
    console.log('Page loaded and game initialized.');
};


function restartGame() {
    socket.emit('reset_scoreboard', { room: currentRoomId });

    updateRoundNumberDisplay(); // Reset the round number display
    // Hide game-over and game-results screens
    document.getElementById('game-over').style.display = 'none';

    document.getElementById('game-results').style.display = 'none';
    document.getElementById('game-end-screen').style.display = 'none'; // Hide the orange overlay

    // Show the black overlay with the OtterGuesser logo
    document.getElementById('loading-screen').style.display = 'flex';

    // Make the "Start Game" button and country selector visible
    document.getElementById('rounds-window').style.display = 'block';
    document.getElementById('country-selector').style.display = 'block';

    localStorage.setItem('gameInProgress', 'false'); // Update game progress state
    showRoundsWindow(); // Ensure the rounds window is shown correctly

    // Emit the "admin_play_again" event to trigger the action for all players
    socket.emit('admin_play_again', { room: currentRoomId });
}



updateRoundNumberDisplay();




                        window.onload = initialize;


function initMap() {
    var fixedLatLng = new google.maps.LatLng(48.8566, 2.3522); // Example fixed coordinates (Paris, France)

    var mapOptions = {
        center: fixedLatLng,       // Fixed center for the map
        zoom: 2,                  // Fixed zoom level
        fullscreenControl: false,  // Keep the fullscreen control disabled
        zoomControl: false,        // Disable zoom controls
        streetViewControl: false,  // Disable Street View Pegman
        mapTypeControl: false,     // Disable map type (satellite/normal) control
        styles: [{                 // Style to hide business POIs (if needed)
            featureType: "poi.business",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
        }]
    };

    map = new google.maps.Map(document.getElementById('map'), mapOptions);

    // Add a click event listener to the map
// Assuming this function is called when the map is clicked
map.addListener('click', function(event) {
    clearInterval(timer);
    console.log('Map clicked, timer stopped.');

    // Debugging: Log the current state
    console.log('Current Round:', currentRound);
    console.log('Generated Locations:', JSON.stringify(generatedLocations));
    console.log('Clicked Location:', event.latLng.toString());

    // Ensure that the clicked location is valid
    if (event.latLng && typeof event.latLng.lat === 'function' && typeof event.latLng.lng === 'function') {
        var clickedLatLng = event.latLng;
        userClickedLocations.push(clickedLatLng);

        // Check if the generated location for the current round is valid
        if (generatedLocations[currentRound] && typeof generatedLocations[currentRound].lat === 'function' && typeof generatedLocations[currentRound].lng === 'function') {
            var generatedLatLng = generatedLocations[currentRound];

        // Validate generated location data
        if (generatedLatLng && typeof generatedLatLng.lat === 'function' && typeof generatedLatLng.lng === 'function') {
            // Proceed with your logic
            var distance = google.maps.geometry.spherical.computeDistanceBetween(generatedLatLng, clickedLatLng);
            var score = calculateScore(distance);
            roundScores[currentRound] = score;
            totalScore += score;
            document.getElementById('score').textContent = totalScore;

            endRound(clickedLatLng, generatedLatLng, score);
        } } else {
            console.error('Invalid generated location data for current round:', currentRound, generatedLocations[currentRound]);
        }

        if (currentRound === totalRounds - 1) {
            endGame();
        } else {
            currentRound++;
        }
    } else {
        console.error('Invalid click location data');
    }
});







}

                function calculateDistance(lat1, lng1, lat2, lng2) {
    var earthRadiusKm = 6371;

    var dLat = degreesToRadians(lat2-lat1);
    var dLng = degreesToRadians(lng2-lng1);

    lat1 = degreesToRadians(lat1);
    lat2 = degreesToRadians(lat2);

    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.sin(dLng/2) * Math.sin(dLng/2) * Math.cos(lat1) * Math.cos(lat2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return earthRadiusKm * c;
}

function degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
}


function endRound(userLatLng, correctLatLng) {
    var distance = calculateDistance(userLatLng.lat(), userLatLng.lng(), correctLatLng.lat(), correctLatLng.lng());
    var roundScore = roundScores[currentRound]; // Retrieve the score for the current round

    document.getElementById('result-text').innerHTML = `You clicked at (${userLatLng.lat().toFixed(5)}, ${userLatLng.lng().toFixed(5)}). The correct coordinates were (${correctLatLng.lat().toFixed(5)}, ${correctLatLng.lng().toFixed(5)}). These locations are ${Math.round(distance)} kilometers away. Your score for this round is: ${roundScore}.`;

    displayResultMap(userLatLng, correctLatLng);
    document.getElementById('round-end-overlay').style.display = 'flex';


    console.log("Current Round: " + currentRound + ", Score for this round: " + score);
    console.log("Total Rounds: " + totalRounds);

    var roundEndButton = document.getElementById('round-end-button');
    if (currentRound === totalRounds - 1) {
        // Last round - change the button text and function
        roundEndButton.innerText = 'Show Results';
        roundEndButton.onclick = function() {
            document.getElementById('round-end-overlay').style.display = 'none';
            endGame(); // Call endGame only when this button is clicked
        };
    } else {
        // Not the last round - keep the next round function
        roundEndButton.innerText = 'Next Round';
        roundEndButton.onclick = nextRound;
    }

    document.getElementById('round-end-overlay').style.display = 'flex';
}

function nextRound() {
    clearInterval(timer); // Clear the timer
    updateRoundNumberDisplay(); // Update the round number display
    if (currentRound >= totalRounds) {
        endGame();
        return;
    }
    document.getElementById('round-end-overlay').style.display = 'none';
    fetchStreetView();
}


function displayResultMap(userLatLng, correctLatLng) {
    var map = new google.maps.Map(document.getElementById('result-map'), {
        center: userLatLng,
        zoom: 2 // Set the zoom level to 1
    });

    new google.maps.Marker({
        position: userLatLng,
        map: map,
        label: {
            text: 'Your Otterguess', // Text for the label
            color: '#000000', // Text color
            fontWeight: 'bold', // Make text bold
            fontSize: '14px' // Text size
        },
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 10,
            fillColor: "#FF0000",
            fillOpacity: 0.4,
            strokeWeight: 1
        }
    });

    new google.maps.Marker({
        position: correctLatLng,
        map: map,
        label: {
            text: 'Actual location', // Text for the label
            color: '#000000', // Text color
            fontWeight: 'bold', // Make text bold
            fontSize: '14px' // Text size
        },
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 10,
            fillColor: "#00FF00",
            fillOpacity: 0.4,
            strokeWeight: 1
        }
    });
}

async function getLocationName(latLng) {
    var response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${latLng.lat()},${latLng.lng()}&key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY`);
        var data = await response.json();

    if (data.results.length > 0) {
        var result = data.results[0];
        var addressComponents = result.address_components;
        var locality = addressComponents.find(c => c.types.includes('locality'))?.long_name;
        var adminArea = addressComponents.find(c => c.types.includes('administrative_area_level_1'))?.long_name;
        var country = addressComponents.find(c => c.types.includes('country'))?.long_name;

        var address = [locality, adminArea, country].filter(Boolean).join(", ");
        return address || result.formatted_address;
    } else {
        return "Unknown location";
    }
}

async function endRound(userLatLng, correctLatLng, score) {
    // Validate that both userLatLng and correctLatLng are valid
    if (!userLatLng || !correctLatLng || typeof userLatLng.lat !== 'function' || typeof correctLatLng.lat !== 'function') {
        console.error('Invalid location data for round end');
        return; // Exit the function if data is invalid
    }
    var userLocationName = await getLocationName(userLatLng);
    var correctLocationName = await getLocationName(correctLatLng);
    var distance = calculateDistance(userLatLng.lat(), userLatLng.lng(), correctLatLng.lat(), correctLatLng.lng());

    document.getElementById('result-text').innerHTML = `
        You clicked at <a href="https://www.google.com/maps/search/?api=1&query=${userLatLng.lat()},${userLatLng.lng()}" target="_blank" style="color: white; font-weight: bold;">${userLocationName}</a>.
        The correct location was <a href="https://www.google.com/maps/search/?api=1&query=${correctLatLng.lat()},${correctLatLng.lng()}" target="_blank" style="color: white; font-weight: bold;">${correctLocationName}</a>.
        These locations are ${Math.round(distance)} kilometers away.
        Your score for this round is: ${score}.`;

    displayResultMap(userLatLng, correctLatLng);
    document.getElementById('round-end-overlay').style.display = 'flex';
}





    </script>
	        <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script>

	<script>
var socket = io();

function createServer() {
    console.log("Debug: createServer function called");
    var serverName = prompt("Enter a name for the new server:");
    if (serverName) {
        socket.emit('create', { room: serverName });
        console.log("Debug: Attempting to create server with name:", serverName);
    }
}

function refreshServerList() {
    console.log("Debug: refreshServerList function called");
    socket.emit('list_rooms');
}

socket.on('assigned_nickname', function(data) {
    console.log("Debug: Assigned nickname:", data.nickname);
});

socket.on('multiplayer_game_created', function(data) {
    console.log("Debug: Multiplayer game created. Settings:", data);
    document.getElementById('game-start-announcement').style.display = 'block';

    // Update totalRounds from the game settings received
    totalRounds = parseInt(data.numRounds);

    // Start the first round and update the round number display
    currentRound = 0; // Reset current round to 0
    updateRoundNumberDisplay(); // Update the round number display
    startRound(true); // Indicate this is the first round
    document.getElementById('loading-screen').style.display = 'none';
});
function joinOrCreateGame() {
    console.log("Debug: joinOrCreateGame function called");
    var roomName = prompt("Enter room name to join or leave blank to create a new room:");
    if (roomName) {
        socket.emit('join', { room: roomName });
        console.log("Debug: Attempting to join room", roomName);
    } else {
        createServer();
    }
}

socket.on('current_players', function(data) {
    if (data.room === currentRoomId) {
        console.log("Debug: Starting new round in multiplayer game, in server " + currentRoomId + ", with players " + data.players.join(", "));
    }
});

socket.on('get_current_players', data => {
    const room = data.room;
    const players = getPlayersInRoom(room); // Function to retrieve players in the specified room
    socket.emit('current_players', { room: room, players: players.map(player => player.nickname) });
});



// Add the new updateScoreboard function
function updateScoreboard() {
    // Emit an event to the server to update the scoreboard with the server identifier
    socket.emit('update_scoreboard', { score: totalScore, room: currentRoomId });

    // Log for debugging
    console.log('Scoreboard updated, because player finished playing with score:', totalScore);
}

socket.on('update_scoreboard', data => {
    const { score, room } = data;
    // Logic to update the scoreboard specifically for the room/server
    const updatedScoreboard = updateServerScoreboard(score, room);

    // Emit the updated scoreboard back to clients in that room
    io.to(room).emit('scoreboard_updated', { scoreboard: updatedScoreboard });
});


socket.on('scoreboard_update', function(data) {
    console.log('Scoreboard updated:', data.scoreboard);
    updateScoreboardDisplay(data.scoreboard);
    if (data.scoreboard.every(player => player.isFinished)) {
        console.log("All players have finished playing. SCORES ARE FINAL.");
    }
});


// Add this listener for the "play_again_triggered" event
socket.on('play_again_triggered', function () {
    // Handle the "Play Again" action for all players here
    // You can add your logic for what should happen when the "Play Again" action is triggered

    // For example, you can reset the game state, hide/show elements, etc.
    // Here's a sample implementation:
    
    // Reset the round number display
    updateRoundNumberDisplay();
    
    // Hide game-over and game-results screens
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('game-results').style.display = 'none';
    document.getElementById('game-end-screen').style.display = 'none';
    
    // Show the black overlay with the OtterGuesser logo
    document.getElementById('loading-screen').style.display = 'flex';
    
    // Make the "Start Game" button and country selector visible
    document.getElementById('rounds-window').style.display = 'block';
    document.getElementById('country-selector').style.display = 'block';
    
    // Update game progress state
    localStorage.setItem('gameInProgress', 'false');
    
    // Ensure the rounds window is shown correctly
    showRoundsWindow();
});


// Add the socket event listener for scoreboard updates
socket.on('scoreboard_updated', function(data) {
    var scoreboardHtml = '<h3>Scoreboard:</h3><ol>';
    data.scoreboard.forEach(function(player) {
        scoreboardHtml += `<li>${player.nickname} - ${player.score} points</li>`;
    });
    scoreboardHtml += '</ol>';
    document.getElementById('multiplayer-scoreboard').innerHTML = scoreboardHtml;
});



function updateScoreboardDisplay(scoreboard) {
    var scoreboardHtml = "<h3>Scoreboard:</h3><ol>";
    for (var i = 0; i < scoreboard.length; i++) {
        var player = scoreboard[i];
        scoreboardHtml += `<li>${player.nickname} - ${player.score} points</li>`;
    }
    scoreboardHtml += "</ol>";
    document.getElementById('multiplayer-scoreboard').innerHTML = scoreboardHtml;
}

// Improved Multiplayer Game Data Handling
socket.on('multiplayer_game_data', function(data) {
    if (data && Array.isArray(data.locations)) {
        // Convert to Google Maps LatLng objects and validate each location
        generatedLocations = data.locations.map(loc => {
            if (loc && typeof loc.lat === 'number' && typeof loc.lng === 'number') {
                return new google.maps.LatLng(loc.lat, loc.lng);
            } else {
                console.error('Invalid location format:', loc);
                return null; // Use null as a placeholder for invalid locations
            }
        }).filter(loc => loc !== null); // Filter out invalid locations


        // Update game settings based on received data
        if (typeof data.totalRounds === 'number') {
            totalRounds = data.totalRounds;
        }

        if (typeof data.roundLength === 'number') {
            timePerRound = data.roundLength;
        }

        if (typeof data.enableMovement === 'boolean') {
            allowStreetViewMovement = data.enableMovement;
        }

        // Log the received data for debugging
        console.log('Multiplayer game data received:', data);

 // Debugging: Log the state after receiving multiplayer game data
    console.log('After receiving multiplayer data - Current Round:', currentRound);
    console.log('After receiving multiplayer data - Generated Locations:', JSON.stringify(generatedLocations));
        startGame();
    } else {
        console.error('Invalid multiplayer game data received:', data);
    }
});

function startRound(firstRound = false) {
    console.log("Debug: Starting new round in multiplayer game, in server " + currentRoomId);
    // Retrieve and log the player list for the current server/room
    socket.emit('get_current_players', { room: currentRoomId });

    isGameActive = true;
    if (!firstRound) {
        currentRound++;
    }
    updateRoundNumberDisplay();
    fetchStreetView();
}



function updateRoundNumberDisplay() {
    document.getElementById('round-number').textContent = currentRound + 1; // +1 as rounds start at 0
    document.getElementById('total-rounds').textContent = totalRounds;
}

socket.on('join_room_announcement', function(data) {
    // Check if the announcement is for the current user
    if (socket.id === data.user_id) {
        alert(data.message); // Show popup only for the user who joined
    }
});

socket.on('room_created', function(data) {
    // Check if the server creation message is for the current user
    if (data && data.message) {
        alert(data.message); // Show popup with the server creation message
    }
});

socket.on('admin_notification', function(data) {
    if (data.message) {
        alert(data.message);  // Display the popup message
    }
});

socket.on('player_left_announcement', function(data) {
    if (data.message) {
        alert(data.message);
    }
});




socket.on('room_creation_failed', function(data) {
    if (data && data.message) {
        var message = data.message;
        // Extract room name from the message
        var roomNameMatch = message.match(/Room (.*?) already exists/);
        var roomName = roomNameMatch ? roomNameMatch[1] : 'Unknown';
        alert(`Room ${roomName} already exists.`);
    } else {
        console.error('Room creation failed for an unknown reason.');
    }
});


socket.on('join_error', function() {
    alert("This server doesn't exist.");
    console.log("Debug: join_error - This server doesn't exist.");
});

// Hide pregenerate settings by default
document.getElementById('pregenerate-settings').style.display = 'none';

socket.on('room_created', function(data) {
    console.log("Debug: room_created - You've created server " + data.room + ".");
    currentRoomId = data.room; // Set the current room ID

    // Since the user who creates the server is always the admin, we do not need to check data.isAdmin
    // Directly show the pregenerate settings
    document.getElementById('pregenerate-settings').style.display = 'block';
    console.log("Debug: User is admin, showing pregenerate settings.");
});

// Optionally, handle the event when a user joins a room as an admin
socket.on('joined_as_admin', function(data) {
    if (data.isAdmin) {
        document.getElementById('pregenerate-settings').style.display = 'block';
        console.log("Debug: Joined as admin, showing pregenerate settings.");
    } else {
        document.getElementById('pregenerate-settings').style.display = 'none';
        console.log("Debug: Not joined as admin, hiding pregenerate settings.");
    }
});

// Hide multiplayer game creation settings by default
document.getElementById('multiplayer-game-creation').style.display = 'none';

socket.on('room_created', function(data) {
    console.log("Debug: room_created - You've created server " + data.room + ".");

    // Show the multiplayer game creation settings for the admin
    document.getElementById('multiplayer-game-creation').style.display = 'block';
    console.log("Debug: User is admin, showing multiplayer game creation settings.");
});

socket.on('joined_as_admin', function(data) {
    if (data.isAdmin) {
        // Show multiplayer game creation settings for the admin
        document.getElementById('multiplayer-game-creation').style.display = 'block';
        console.log("Debug: Joined as admin, showing multiplayer game creation settings.");
    } else {
        // Hide multiplayer game creation settings for non-admin users
        document.getElementById('multiplayer-game-creation').style.display = 'none';
        console.log("Debug: Not joined as admin, hiding multiplayer game creation settings.");
    }
});


socket.on('available_rooms', function(rooms) {
    console.log("Available rooms:", rooms);
    var serverList = document.getElementById('server-list');
    serverList.innerHTML = '';  // Clear existing list

    for (var room in rooms) {
        if (rooms.hasOwnProperty(room)) {
            var roomElement = document.createElement('div');
            roomElement.innerHTML = `Room Name: ${room}, Players: ${rooms[room].player_count}<br>`;
            roomElement.style.color = 'black';

            // Add player names and highlight admin
            rooms[room].players.forEach(player => {
                var playerElement = document.createElement('span');
                if (player.admin) {
                    playerElement.innerHTML = `<span style="color: red;">${player.nickname} (Admin)</span><br>`;
                } else {
                    playerElement.textContent = player.nickname + '\n';
                }
                roomElement.appendChild(playerElement);
            });

            roomElement.style.cursor = 'pointer';
            roomElement.onclick = function() {
                socket.emit('join', { room: room });
                console.log("Attempting to join room", room);
            };
            serverList.appendChild(roomElement);
        }
    }

    if (Object.keys(rooms).length === 0) {
        serverList.innerHTML = '<p class="no-rooms-message">No available rooms. Create a new one!</p>';
    }
    console.log("Server list updated");
});


socket.onAny((event, ...args) => {
    console.log(`Debug: Socket.io event received - ${event}`, args);
});

document.addEventListener('DOMContentLoaded', function() {
    var startMultiplayerGameButton = document.getElementById('start-multiplayer-game');
    if (startMultiplayerGameButton) {
        startMultiplayerGameButton.addEventListener('click', function() {
            console.log("Debug: Start multiplayer game button clicked");
            createMultiplayerGame();
        });
    }
});

// Inside the function createMultiplayerGame()
function createMultiplayerGame() {
    var numRounds = document.getElementById('num-rounds').value;
    var timerDuration = document.getElementById('timer-duration').value;
    var enableMovement = document.getElementById('enable-movement').checked;
    var sameLocationForAll = document.getElementById('same-location-for-all').checked; // Get the checkbox value

    var gameSettings = {
        numRounds: numRounds,
        timerDuration: timerDuration,
        enableMovement: enableMovement,
        sameLocationForAll: sameLocationForAll // Include this in the game settings
    };

    console.log("Debug: Multiplayer game creation request sent with settings:", gameSettings);
    socket.emit('create_multiplayer_game', gameSettings);
}






</script>
        <script>
var customLocations = []; // Array to hold custom locations
var customMarkers = []; // Array to hold markers
var customTotalRounds = 0; // Total number of rounds for custom mode
var currentLatLng; // Global variable to store the current location
var customMap; // This will hold the map instance
var customRoundTimerLength = 120; // Default round timer length
var locationSet = false; // Flag to check if a location is set
var customMovementEnabled = true; // Default: Movement enabled


function toggleCustomMovement() {
    customMovementEnabled = !customMovementEnabled;
    var statusText = customMovementEnabled ? 'Enabled' : 'Disabled';
    var statusColor = customMovementEnabled ? 'green' : 'red';
    document.getElementById('custom-movement-status').textContent = statusText;
    document.getElementById('custom-movement-status').style.color = statusColor;
    alert('Street View movement in custom mode is now ' + statusText + '.');
}




function initCustomMap() {
    var mapOptions = {
        center: { lat: 48.8566, lng: 2.3522 },
        zoom: 3,
        streetViewControl: true,
        mapTypeId: google.maps.MapTypeId.ROADMAP
    };

    customMap = new google.maps.Map(document.getElementById('custom-map'), mapOptions);
    var streetView = customMap.getStreetView();

    google.maps.event.addListener(streetView, 'visible_changed', function() {
        if (streetView.getVisible()) {
            setTimeout(() => {
                currentLatLng = streetView.getPosition();
                locationSet = true;
                console.log('Current location updated (Street View Entered):', currentLatLng.lat(), currentLatLng.lng());
            }, 500);
        }
    });

    google.maps.event.addListener(streetView, 'position_changed', function() {
        currentLatLng = streetView.getPosition();
        locationSet = true;
        console.log('Current location updated (Street View Movement):', currentLatLng.lat(), currentLatLng.lng());
    });
}

function saveLocation() {
    if (locationSet && currentLatLng && typeof currentLatLng.lat === 'function' && typeof currentLatLng.lng === 'function') {
        if (!customLocations.some(loc => loc.lat() === currentLatLng.lat() && loc.lng() === currentLatLng.lng())) {
            customLocations.push(currentLatLng);
            console.log('Location saved into the custom games file:', currentLatLng.lat(), currentLatLng.lng());

            // Create a new marker and add it to the map and customMarkers array
            var marker = new google.maps.Marker({
                position: currentLatLng,
                map: customMap
            });
            customMarkers.push(marker); // Save the marker

            alert("Location number " + customLocations.length + " at (" + currentLatLng.lat().toFixed(5) + ", " + currentLatLng.lng().toFixed(5) + ") saved.\n\nContinue to place more locations, or download your custom mode!");
            currentLatLng = null;
            locationSet = false;
            document.getElementById('custom-location-count').textContent = customLocations.length; // Update the count of saved locations
            if (customLocations.length > 0) {
                document.getElementById('download-custom-file').style.display = 'block';
            }
            console.log('Saved locations updated. Count:', customLocations.length); // Debugging
     }
         }
         }



function launchCustomGenerationMode() {
    var editor = document.getElementById('custom-location-editor');
    editor.style.display = (editor.style.display === "block") ? "none" : "block";
    initCustomMap(); // Initialize the custom map with Street View enabled
}



    function showGuide() {
        alert("Welcome to the editor!\n\n" +
              "1. Use the yellow stickman icon to get into street view of your favorite location.\n" +
              "2. (Optional): Move around to find the perfect spot.\n" +
              "3. Press 'Save location' to save your favorite location. 1 location = 1 round.\n" +
              "4. (Optional): Set the round timer / disable movement.\n" +
              "5. Press 'Download custom mode!' to download your mode.\n\n" +
              "You can now use this file to play your custom made mode!\n\n" +
              "(Please note, only regular street views are supported. Static places like museums or indoors (anywhere where the user cannot move) are not supported. See console - F12, for whether your location has been saved successfully.)");
    }




// Add a global variable for custom round timer length
var customRoundTimerLength = 120;

// Function to change custom round timer length
function setCustomRoundTimerLength() {
    var timerLengthInput = document.getElementById('custom-timer-input').value;
    customRoundTimerLength = parseInt(timerLengthInput);
    document.getElementById('custom-timer-display').textContent = customRoundTimerLength; // Update the displayed timer duration
    alert('Custom mode timer changed to ' + customRoundTimerLength + ' seconds.');
}



function downloadCustomLocationsFile() {
    // Ensure there is at least one location saved
    if (customLocations.length === 0) {
        alert("Please save at least one location before downloading the file.");
        return;
    }

    // Set the total number of rounds based on the number of saved locations
    customTotalRounds = customLocations.length;

    var customGameData = {
        locations: customLocations.map(loc => ({ lat: loc.lat(), lng: loc.lng() })),
        randomFileName: generateRandomFileName(),
        totalRounds: customTotalRounds,
        roundLength: customRoundTimerLength,
        movementEnabled: customMovementEnabled
    };

    var blob = new Blob([JSON.stringify(customGameData)], { type: 'application/json' });
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = customGameData.randomFileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    // Popup message
    var movementStatus = customMovementEnabled ? 'enabled' : 'disabled';
    alert(`File ${customGameData.randomFileName} generated, containing ${customTotalRounds} rounds, round timer of ${customRoundTimerLength} seconds, and movement ${movementStatus}. Have fun!`);

    // Reset the editor values
    resetCustomEditor();
}


function resetCustomEditor() {
    // Remove all markers from the map
    for (var i = 0; i < customMarkers.length; i++) {
        if (customMarkers[i]) {
            customMarkers[i].setMap(null);
        }
    }

    // Reset the arrays and other values
    customMarkers = [];
    customLocations = [];
    customTotalRounds = 0;
    currentLatLng = null;
    locationSet = false;
    customRoundTimerLength = 120;
    customMovementEnabled = true;

    // Reset UI elements
    document.getElementById('custom-timer-input').value = 120;
    document.getElementById('download-custom-file').style.display = 'none';
    document.getElementById('custom-timer-display').textContent = '120'; // Reset timer display
    document.getElementById('custom-movement-status').textContent = 'Enabled'; // Reset movement status
    document.getElementById('custom-movement-status').style.color = 'green';
    document.getElementById('custom-location-count').textContent = '0'; // Reset saved locations count

    console.log('Custom editor reset. All markers cleared.'); // Debugging
}

function launchCustomGenerationMode() {
    var editor = document.getElementById('custom-location-editor');
    if (editor.style.display === "block") {
        editor.style.display = "none";
    } else {
        editor.style.display = "block";
        initCustomMap(); // Initialize the custom map with Street View enabled
    }
}

function toggleCustomGenerationMode() {
    var editor = document.getElementById('custom-location-editor');
    editor.style.display = "none";
}

function refreshServerList() {
    socket.emit('list_rooms'); // Request the list of available rooms
}

// Automatically refresh the server list every 5 seconds
setInterval(refreshServerList, 5000);

// Initial server list refresh
refreshServerList();
</script>
<script>
function toggleMapDisplay() {
    console.log("Toggling map display"); // Debugging
    var map = document.getElementById('map');
    if (map.style.display === 'none' || map.style.display === '') {
        console.log("Displaying map"); // Debugging
        map.style.display = 'block';
    } else {
        console.log("Hiding map"); // Debugging
        map.style.display = 'none';
    }
}
</script>

        <script>
        function reloadLocation() {
    radiusIndex = 0;
    fetchStreetView();
}
</script>

<script>
function toggleClassicMode() {
    var classicModeSettings = document.getElementById('classic-mode-settings');
    var customModeSettings = document.getElementById('custom-mode-settings');
    var onlineMultiplayerSettings = document.getElementById('online-multiplayer-settings');

    classicModeSettings.style.display = classicModeSettings.style.display === 'none' ? 'block' : 'none';
    customModeSettings.style.display = 'none';
    onlineMultiplayerSettings.style.display = 'none';
}

function toggleCustomMode() {
    var classicModeSettings = document.getElementById('classic-mode-settings');
    var customModeSettings = document.getElementById('custom-mode-settings');
    var onlineMultiplayerSettings = document.getElementById('online-multiplayer-settings');

    customModeSettings.style.display = customModeSettings.style.display === 'none' ? 'block' : 'none';
    classicModeSettings.style.display = 'none';
    onlineMultiplayerSettings.style.display = 'none';
}

function toggleOnlineMultiplayer() {
    var classicModeSettings = document.getElementById('classic-mode-settings');
    var customModeSettings = document.getElementById('custom-mode-settings');
    var onlineMultiplayerSettings = document.getElementById('online-multiplayer-settings');

    onlineMultiplayerSettings.style.display = onlineMultiplayerSettings.style.display === 'none' ? 'block' : 'none';
    classicModeSettings.style.display = 'none';
    customModeSettings.style.display = 'none';
}
</script>


<script>
// Assuming currentRoomId is a global variable
var currentRoomId; // Make sure this is initialized somewhere in your code

async function pregenerateRounds() {
    // Show the loading overlay
    document.getElementById('loading-pregeneration-overlay').style.display = 'flex';

 
    var numRounds = parseInt(document.getElementById('pregenerate-rounds-input').value);
    console.debug("SYNDICATION: Locations are being pregenerated.");
    let pregeneratedLocations = [];

    for (let i = 0; i < numRounds; i++) {
        let location = await generateLocation();
        pregeneratedLocations.push(location);
    }

    // Check if currentRoomId is defined
     if (!currentRoomId) {
        console.error("Error: currentRoomId is not defined.");
        return;
    }

socket.emit('admin_pregenerated_locations', { room: currentRoomId, locations: pregeneratedLocations });

}


// Server Side: Handling the Admin's Emitted Event (Example in Node.js with socket.io)
socket.on('admin_pregenerated_locations', data => {
    const { room, locations } = data;
    // Broadcasting to all clients in the room
    io.to(room).emit('pregenerated_locations_for_clients', { locations: locations });
});


// Client Side: Listening for Pregenerated Locations
socket.on('pregenerated_locations_for_clients', data => {
    if (isAdmin) {
        console.debug(`SYNDICATION COMPLETE: Locations ${formatLocations(data.locations)} have been pregenerated. The game will consist of ${data.locations.length} rounds.`);
    } else {
        console.debug(`SYNDICATION COMPLETE: Locations ${formatLocations(data.locations)} have been pregenerated by the admin, and synchronized with your client. The game will consist of ${data.locations.length} rounds.`);
    }
    // Store the locations and use them for the game
    pregeneratedLocations = data.locations;
});

// Helper Function to Format Locations for Debug Message
function formatLocations(locations) {
    return locations.map(loc => `(${loc.lat.toFixed(5)}, ${loc.lng.toFixed(5)})`).join(", ");
}



async function generateLocation() {
    const maxRetries = 20; // Number of retries to find a valid location
    const searchRadius = [50, 100, 500]; // Search radii in km

    for (let retries = 0; retries < maxRetries; retries++) {
        var box = selectBoundingBox();
        var lat = Math.random() * (box.maxLat - box.minLat) + box.minLat;
        var lng = Math.random() * (box.maxLng - box.minLng) + box.minLng;
        var latLng = new google.maps.LatLng(lat, lng);

        var isLandAndWaterChecked = await checkLandOrWater(latLng);
        if (!isLandAndWaterChecked) {
            console.log('Generated coords found in the sea, retrying...');
            continue;
        }

        for (let radius of searchRadius) {
            var streetViewData = await getStreetViewData(latLng, radius * 1000); // Convert km to meters
            if (streetViewData) {
                generatedLocations.push(streetViewData); // Push the location where Street View was found
                console.log(`Location with Street View found, with lat value ${streetViewData.lat()} and lng value ${streetViewData.lng()}:`, streetViewData);
                return streetViewData; // Successful generation, exit the function
            }
        }
        console.log('Searching in a wider radius...');
    }
    console.log('Failed to generate a valid location after several retries.');
    return null; // Return null if no valid location is found
}

async function getStreetViewData(latLng, radius) {
    return new Promise(resolve => {
        var sv = new google.maps.StreetViewService();
        sv.getPanorama({
            location: latLng,
            radius: radius,
            source: google.maps.StreetViewSource.OUTDOOR
        }, function(data, status) {
            if (status === google.maps.StreetViewStatus.OK) {
                resolve(data.location.latLng); // Return the location where Street View was found
            } else {
                resolve(null);
            }
        });
    });
}


function selectBoundingBox() {
    var selectedCountry = document.getElementById('country-selector').value;
    if (selectedCountry && countryBoundingBoxes[selectedCountry]) {
        return countryBoundingBoxes[selectedCountry];
    }
    return allBoundingBoxes[Math.floor(Math.random() * allBoundingBoxes.length)];
}


async function processStreetViewData(latLng) {
    var sv = new google.maps.StreetViewService();
    sv.getPanorama({
        location: latLng,
        radius: 50,  // Adjust as needed
        source: google.maps.StreetViewSource.OUTDOOR
    }, function(data, status) {
        if (status === google.maps.StreetViewStatus.OK) {
            // Logic to handle valid Street View data
            console.log('Pair for location found at', data.location.latLng);
            // Emit or broadcast this location to all players
            emitLocationData(data.location.latLng);
            startTimer();  // If relevant in multiplayer
            initMap(data.location.latLng);  // Update the map for all players
        } else {
            console.log('No roads nearby, fetching a new panorama...');
            generateLocation();  // Generate a new location
        }
    });
}

function emitLocationData(latLng) {
    // Use socket.io to emit this data to all clients
    socket.emit('new_location_data', { lat: latLng.lat(), lng: latLng.lng() });
}


async function checkStreetViewAvailability(latLng, radius) {
    return new Promise(resolve => {
        var sv = new google.maps.StreetViewService();
        sv.getPanorama({
            location: latLng,
            radius: radius,
            source: google.maps.StreetViewSource.OUTDOOR
        }, function(data, status) {
            resolve(status === google.maps.StreetViewStatus.OK);
        });
    });
}

// Attach the event listener
document.addEventListener('DOMContentLoaded', function() {
    var pregenerateButton = document.getElementById('pregenerate-rounds-button');
    if (pregenerateButton) {
        pregenerateButton.addEventListener('click', pregenerateRounds);
    }
});


socket.on('pregenerating_locations', function(data) {
    console.log(data.message);
});

// Listen for the 'pregenerated_admin_notification' event
socket.on('pregenerated_admin_notification', function(data) {
    var numRounds = data.num_rounds;
    var message = `${numRounds} locations have been pregenerated. If you want the locations of every round to be the same for each player, choose ${numRounds} rounds. You can also make the game shorter. If you decide to make the game longer, locations past round ${numRounds} will be different for each player.`;
    alert(message);
});


socket.on('pregenerating_locations_admin', function(data) {
    console.log(data.message);
});

socket.on('locations_pregenerated', function(data) {
 // Hide the loading overlay
    document.getElementById('loading-pregeneration-overlay').style.display = 'none';

    console.log('Received data:', data);

    if (Array.isArray(data.locations) && data.locations.length > 0) {
        var validLocations = data.locations.filter(loc => loc && typeof loc.lat === 'number' && typeof loc.lng === 'number');
        
        if (validLocations.length === 0) {
            console.error('No valid location data received. All locations are null or invalid.');
            // Optionally, request the server to regenerate locations
            socket.emit('request_regenerate_locations');
        } else {
            console.log('Valid locations received:', validLocations);
            // Proceed with game setup using valid locations
            generatedLocations = validLocations.map(loc => new google.maps.LatLng(loc.lat, loc.lng));
        }
    } else {
        console.error('Invalid location data format received:', data.locations);
        // Handle invalid data format
    }
});

</script>


<script>
function closeGameResults() {
    // Hide the game results container
    document.getElementById('game-results').style.display = 'none';

    // Hide the close button
    document.getElementById('close-game-results').style.display = 'none';
}

</script>

    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyChOHZaT2T-YnRPTHdamiKhrNuELMGUAUY&callback=initialize"></script>
        <button id="reload-button" style="display:none" onclick="reloadLocation()">reload</button>


    <div id="score-display">Points: <span id="score">0</span></div>

<div id="game-over">
    <p>Game over. You won <span id="total-points">0</span> points!</p>
    <div id="gameover-map" style="width: 780px; height: 600px; margin-top: 20px;"></div> <!-- New Map Container -->
    <button id="play-again-button" onclick="restartGame()">Play Again</button>

<button id="close-game-results" onclick="closeGameResults()" style="...">Close results</button>

<div id="multiplayer-scoreboard"></div>


</div>




<div id="game-results">
</div> <!-- New div for game results -->


</body>
</html>
